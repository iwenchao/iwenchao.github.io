<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="java," />





  <link rel="alternate" href="/atom.xml" title="大王派我来巡山" type="application/atom+xml" />






<meta name="description" content="Java主要方面 面向对象的特性 集合（特点，数据结构（数组，栈，队列，双向队列，红黑树，二叉树等）） JVM虚拟机（加载机制/内存以及垃圾回收） 线程与进程，异步 注解/反射/泛型 设计模式（单例，建造者，适配器，工厂，策略，观察者，代理） 算法（数据结构/排序，查找等）   面向对象的特征 抽象：针对某一类对象的共同特征总结出来构造类的过程，抽象只关注对象有哪些共同的属性和行为，而不关心具体">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java的常用知识整理">
<meta property="og:url" content="http://wenchaos.com/java基础篇/java的常用知识整理/index.html">
<meta property="og:site_name" content="大王派我来巡山">
<meta property="og:description" content="Java主要方面 面向对象的特性 集合（特点，数据结构（数组，栈，队列，双向队列，红黑树，二叉树等）） JVM虚拟机（加载机制/内存以及垃圾回收） 线程与进程，异步 注解/反射/泛型 设计模式（单例，建造者，适配器，工厂，策略，观察者，代理） 算法（数据结构/排序，查找等）   面向对象的特征 抽象：针对某一类对象的共同特征总结出来构造类的过程，抽象只关注对象有哪些共同的属性和行为，而不关心具体">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-07-28T07:55:34.213Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java的常用知识整理">
<meta name="twitter:description" content="Java主要方面 面向对象的特性 集合（特点，数据结构（数组，栈，队列，双向队列，红黑树，二叉树等）） JVM虚拟机（加载机制/内存以及垃圾回收） 线程与进程，异步 注解/反射/泛型 设计模式（单例，建造者，适配器，工厂，策略，观察者，代理） 算法（数据结构/排序，查找等）   面向对象的特征 抽象：针对某一类对象的共同特征总结出来构造类的过程，抽象只关注对象有哪些共同的属性和行为，而不关心具体">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://wenchaos.com/java基础篇/java的常用知识整理/"/>





  <title>Java的常用知识整理 | 大王派我来巡山</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大王派我来巡山</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wenchaos.com/java基础篇/java的常用知识整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wenchaos">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大王派我来巡山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java的常用知识整理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-28T00:00:00+08:00">
                2018-03-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/java基础篇/java的常用知识整理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="java基础篇/java的常用知识整理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6,543
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  24
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <ol>
<li>Java主要方面<ol>
<li>面向对象的特性</li>
<li>集合（特点，数据结构（数组，栈，队列，双向队列，红黑树，二叉树等））</li>
<li>JVM虚拟机（加载机制/内存以及垃圾回收）</li>
<li>线程与进程，异步</li>
<li>注解/反射/泛型</li>
<li>设计模式（单例，建造者，适配器，工厂，策略，观察者，代理）</li>
<li>算法（数据结构/排序，查找等）</li>
</ol>
</li>
<li>面向对象的特征<ol>
<li>抽象：针对某一类对象的共同特征总结出来构造类的过程，抽象只关注对象有哪些共同的属性和行为，而不关心具体内容<ol>
<li>数据抽象</li>
<li>行为抽象</li>
</ol>
</li>
<li>继承：从已有类得到继承信息创建新类的过程。</li>
<li>封装：通常认为封装是把数据和行为绑定起来，对数据的访问只能通过定义的接口。封装就是隐藏一切可以隐藏的东西，只向外界提供最简单的编程接口。</li>
<li>多态性：指的是允许不同子类型的对象对同一消息作出不同的行为。即同样的对象引用调用同样的方法，但是做了不同的事情。<ol>
<li>编译时多态：方法重载（前期绑定），同一个类中，同名方法不同参；对返回值没有要求</li>
<li>运行时多态：方法重写（后期绑定），<ol>
<li>父子类中，即 子类继承父类已有的或者抽象的方法；</li>
<li>返回类型相同，</li>
<li>修饰符权限更开放，</li>
<li>不能比父类声明更多的异常（里氏替换原则）</li>
<li>方法重写，2. 对象造型（向下）即：用父类型引用 引用子类型对象实例，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为</li>
</ol>
</li>
<li>多态性的作用：<ol>
<li>封装：可以隐藏实现细节，便于模块化；继承可以扩展已存在的类；封装和继承都是为了代码重用性，而多态则是为了实现—接口重用！真正具有价值的重用就是“接口重用”，因为接口设计比实现接口更费时间，更花费工程师的精力。</li>
</ol>
</li>
</ol>
</li>
<li>问题：<ol>
<li>问题：从JVM/深一层的角度具体描述一下实现的机制？？？</li>
<li>继承与组合的不同</li>
</ol>
</li>
</ol>
</li>
<li>访问修饰符的区别<ol>
<li>public：对所有类公开，不论是不是同一包下</li>
<li>protect ：仅仅对同包下子类公开</li>
<li>default：默认对于同一个包下的其他类相当于public，非同一个包下的相当于private</li>
<li>private：仅仅当前类中可以访问到</li>
</ol>
</li>
<li>java面试题180 <ol>
<li>（上） <a href="http://blog.csdn.net/jackfrued/article/details/44921941" target="_blank" rel="noopener">http://blog.csdn.net/jackfrued/article/details/44921941</a>  例：</li>
<li>String是基本类型吗？答：不是，基本类型有八种：byte ,short , int , long , double , float , char , boolean; 其他的都是引用类型，Java5引入的枚举enum也属于引用类型</li>
</ol>
</li>
<li>解释内存中的栈（stack）堆（heap）和方法区（method area）<ol>
<li>栈空间：通常基本数据类型，对象的引用，以及函数调用的现场保存 </li>
<li>堆空间：通过new或者构造器创建的对象 （垃圾回收的主要区域，因为垃圾回收器大多数采用分代收集算法，所以堆空间还细分了 新生代，老生代）</li>
<li>方法区：</li>
<li>方法区和堆空间都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息，常量，静态变量，JIT编译器编译后的代码等数据；</li>
<li>程序中的字面量，如100，“Hello”和常量都是放在常量池中，常量池是方法区的一部分</li>
<li>栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数进行调整</li>
<li>栈空间用光了会引发StackOverflowError，而堆空间和常量池不足则会引发OutOfMemoryError</li>
<li>例子：String str = new String（“Hello”）中，变量str，作为引用，放在栈中；new创建的字符串对象放在堆上，而“Hello”这个字面量放在方法区</li>
<li>补充：<ol>
<li>Java6 开始，由于JIT编译器的发展和“逃逸技术”逐渐成熟，栈上分配，标量替换等优化技术使得对象不一定非得分配在堆中；</li>
<li>运行时常量池相当于Class文件常量池具有动态性，Java语言并不要求常量一定只有编译器才能产生，运行期也可以将新的常量放入池中，String的intern()方法就是这样；</li>
</ol>
</li>
</ol>
</li>
<li>switch能否作用在byte，long上？String呢；（为什么？？？）<ol>
<li>答：Java 5 以前只能是byte ，short，char，int ；java 5 开始引入enum；Java 7 开始引入String；而long不可以；</li>
</ol>
</li>
<li>两个对象值相同（x.equals(y) == true），但却可以有不同的hash code吗？<ol>
<li>答：不对；Java对于equals方法和hashcode方法是这样规定：</li>
<li>如果两个对象相同（x.equals(y) == true），那么他们的hashCode值一定要相同；</li>
<li>如果两个对象hashCode相同，他们不一定相同；</li>
<li>补充：如果违背了java的这种规则，就会发现：在使用容器时，相同的对象可以set集合中出现，同时增加新元素的效率大大下降（这是因为使用哈希存储的系统，如果哈希码频繁的冲突，将会造成存取性能的急剧下降）</li>
<li>补充：equals方法必须满足：自反性，对称性，传递性，一致性</li>
<li>补充：重写equals方法的优秀要求：<ol>
<li><ol>
<li>使用==操作符检查”参数是否为这个对象的引用”；</li>
</ol>
</li>
<li><ol>
<li>使用instanceof操作符检查”参数是否为正确的类型”；</li>
</ol>
</li>
<li><ol>
<li>对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；</li>
</ol>
</li>
<li><ol>
<li>编写完equals方法后，问自己它是否满足对称性、传递性、一致性；</li>
</ol>
</li>
<li><ol>
<li>重写equals时总是要重写hashCode；</li>
</ol>
</li>
<li><ol>
<li>不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。  </li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>String和StringBuilder StringBuffer的区别<ol>
<li>String：不可变，只读</li>
<li>StringBuilder：可修改，Java 5引入，单线程，因为没有被做线程安全的处理，所以效率比StringBuffer高</li>
<li>StringBuffer：可修改，多线程安全，效率相对低</li>
<li>补充：什么情况下用 +运算符进行字符串连接，比用StringBuffer和StringBuilder性能好；<ol>
<li>+运算符的操作本质是创建了StringBuilder对象进行append操作，然后将结果toString</li>
</ol>
</li>
</ol>
</li>
<li>描述一下JVM加载class文件的原理机制<ol>
<li>JVM中类的装载是由类加载器（classLoader）和他的子类来实现的；是java运行时系统的一个重要组件，负责在运行时查找和装入类文件</li>
<li>由于java的跨平台型，经过编译的java源程序并不是一个可执行程序，而是一个或多个中间文件。</li>
<li>当java程序需要某个文件时，JVM会确保这个类已经被加载–&gt;链接（验证—&gt; 准备—&gt;解析）—&gt;初始化。类的加载是指把类的.class文件读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。</li>
<li>加载完成后，Class对象还不完整，还不可用。被加载后，进入连接过程，包括验证，，准备（为静态变量分配内存，设置初始值）和解析（将符号引用替换成直接引用）。</li>
<li>最后JVM对类进行初始化。如果该类存在直接的父类并且这个父类也还没有被初始化，则先初始化父类；如果该类中存在初始化语句，就依次执行这些初始化语句</li>
<li>类加载器：<ol>
<li>根加载器：Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）（不是java语言所编写的）</li>
<li>扩展加载器：Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；</li>
<li>系统加载器：System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</li>
<li>用户自定义加载器：</li>
<li>加载流程：应用启动：JVM启动—&gt;bootstrap classloader运行，加载java运行的核心类库，同时加载扩展加载器和系统加载器；—&gt;扩展加载器去加载扩展Api，—&gt;app classloader 加载CLASSPATH 目录下定义的class，通常没有特别指定的情况下，程序自定义类文件有系统加载器加载。</li>
</ol>
</li>
<li>双亲委托模式：<ol>
<li>优先判断父类加载器是否已经加载class文件，如果没有则子类进行；若parent classloader为null ，则调用 bootstrap classloader进行加载</li>
<li>优缺点：<ol>
<li>避免重复加载</li>
<li>安全问题：如果不适用这个模式，则有可能造成外来类替换java核心类的安全隐患</li>
</ol>
</li>
<li>流程：<ol>
<li>入口在ClassLoader.loadClass(name,boolean resolve):类名称，是否需要解析类；在执行类之前，需要考虑是否需要解析类，并不总是需要解析，如果JVM只需要知道该类是否存在或找出该类的超类，则不需要解析</li>
<li>defineClass<ol>
<li>接受由原始字节组成的数组，并将之转成Class对象。原始数组包含从文件系统或者网络装入的数据。defineClass管理JVM的许多复杂实现，它把字节码分析成运行时数据结构，校验有效性等。该方法为finla，不可重写</li>
</ol>
</li>
<li>findSystemClass方法<ol>
<li>从本地文件系统装入</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>Class.forName 与classloader加载的类文件有什么区别<ol>
<li>loadClass加载 类实际上是在加载的时候并不对该类进行解析，因此不会初始化该类；而Class.forName则想反，在forName加载的时候就会将Class进行解析以及初始化！</li>
</ol>
</li>
</ol>
</li>
<li>抽象类与接口的区别：<ol>
<li>相同点：<ol>
<li>不能被实例化</li>
<li>可以定义抽象类和接口类型的引用</li>
</ol>
</li>
<li>不同点：<ol>
<li>抽象类：可以有构造器；可以有抽象方法，具体方法；不一定有抽象方法；可以有private、默认、protected、public的成员变量</li>
<li>接口：没有构造器；只能有抽象方法；只能是常量 public static final ；没有静态方法</li>
<li>在继承体系中，抽象类继承是属于is-a的关系；接口的实现属于has-a的关系</li>
</ol>
</li>
<li>语法层面上的区别<ol>
<li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的</li>
<li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ol>
</li>
<li>设计层面上的区别<ol>
<li>抽象层次不同：抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象</li>
<li>跨域不同，抽象类作为很多子类的父类，它是一种具有相似特点的类。而接口是一种行为规范，它可以跨多种域，它是一种辐射式设计</li>
<li>设计层次不同：对于抽象类，它是自子类而父类来设计（自下而上），先知道子类才能抽象出父类，而接口不同，接口只是定义一种行为，不管行为的具体实施。</li>
</ol>
</li>
</ol>
</li>
<li>集合部分<ol>
<li>Collection：Java不提供直接继承Collection<ol>
<li>List：有序，索引，可重复<ol>
<li>ArrayList：<ol>
<li>允许所有元素，包括null</li>
<li>不是线程安全</li>
</ol>
</li>
<li>LinkedList：<ol>
<li>允许null元素，</li>
<li>常常被用作stack，queue，deque（双向队列）</li>
<li>不是线程安全！一种解决方法是在创建List时构造一个同步的List：List list = Collections.synchronizedList(new LinkedList(…));</li>
</ol>
</li>
<li>Vector：线程安全！非常类似ArrayList<ol>
<li>Stack：实现一个后进先出的堆栈；push，pop，peak，empty，search</li>
</ol>
</li>
</ol>
</li>
<li>Set：无重复<ol>
<li>HashSet</li>
<li>TreeSet</li>
<li>LinkedHashSet</li>
</ol>
</li>
<li>Queue<ol>
<li>PriorityQueue</li>
</ol>
</li>
<li>Collection类型的集合都支持iterator()方法，该方法返回一个Iterator it = collection.iterator(); // 获得一个迭代子</li>
</ol>
</li>
<li>Map：内部一个K-V映射的哈希表，由于作为key的对象将通过计算其散列值来确定与之对应的value的位置，因此任何作为key的对象必须实现hashCode，equals方法<ol>
<li>HashMap：键值对允许null，</li>
<li>HashTable：键值对非null，同步的</li>
<li>WeakHashMap：</li>
<li>TreeMap与TreeSet：<ol>
<li>TreeMap继承Map，TreeSet继承Set，TreeSet底层是通过TreeMap来实现的（如同HashSet底层是通过HashMap还实现的）</li>
<li>TreeMap的实现就是红黑树算法</li>
<li>相同点：<ol>
<li>都是有序集合，存储的值都是排好序的；</li>
<li>都是非同步集合，不能在多线程环境中使用，（可以使用Collections.synchronizedMap()进行同步化）</li>
<li>运行速度都要比hash集合慢，内部对元素的操作 时间复杂度为O(logN)，而HashMap/HashSet则为O(1)。因为一个是树结构，一个数组结构</li>
</ol>
</li>
<li>不同点：<ol>
<li>主要区别是实现接口不一样；</li>
<li></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>涉及到堆栈，队列：list</li>
</ol>
</li>
<li>同步异步<ol>
<li>Synchronized，volatile，</li>
<li>java.util.concurrent.locks.Lock</li>
<li>Semaphore信号量</li>
<li>FutureTask：<ol>
<li>类似Runnable，都可以通过Thread来启动；不同的是FutureTask可以返回执行完毕后的数据，并且get（）是阻塞的；</li>
<li>可用于进行资源的预处理/预加载</li>
</ol>
</li>
<li>CyclicBarrier：可以阻塞一组线程，当同时满足条件后，才能解除阻塞继续执行下面的操作；单个线程中调用await（）并不管用；</li>
<li>Executor：线程池</li>
<li>Timer：定时器（偏向于单个任务）<ol>
<li>缺陷<ol>
<li>对于多个任务，timer内部只有一个任务线程，所以某个任务执行时间过长，导致不能按照我们定时器预定的执行；可以用ScheduledThreadPool弥补</li>
<li>一旦TimerTask出现了异常，Timer会停止所有任务的运行</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>序列化以及意义：<ol>
<li>用来处理对象流的一种机制，所谓对象流也就是将对象的内容进行流化，可以对流化后的对象进行读写操作，或者传输于网络之间。序列化是为了解决对象流读写操作过程中可能引发的数据乱序问题。</li>
<li>实现序列化需要实现Serializable接口，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆（可以参考第29题）。</li>
</ol>
</li>
<li>final，finally ，finalize的区别<ol>
<li>final 用于控制成员变量，方法，或者是一个类是否可以被覆写或继承等功能；<ol>
<li>成员：<ol>
<li>一旦初始化后，不可改变；基础类型变量：值不改变，引用类型变量：引用不可改变（其初始化的地方在 声明处或者构造器中）</li>
<li>对于方法参数中final，基础类型的参数没有什么实际意义；但是对于引用类型的参数，因为其传递的是对象的引用，这样你在方法中对对象变量的修改也会影响到调用语句中对象变量。当方法中不需要改变作为参数的这个对象变量时，声明为final，防止你无意中修改到它而影响到方法的调用处。</li>
</ol>
</li>
<li>方法：<ol>
<li>不能重写，但是子类可以继承</li>
<li>允许编译器将所有对此方法的调用转化成inline（行内）调用的机制，它会在调用方法时，直接将方法主体插入到调用处，而不是进行例行的方法调用。提高了程序效率，但是当方法主体很大的时候，反而使得插入地方迅速膨胀，反而影响了效率。</li>
</ol>
</li>
<li>类：<ol>
<li>不可被继承；其中的方法也是默认为final</li>
</ol>
</li>
</ol>
</li>
<li>finally：对捕获异常模型的补充，finally块始终会最后执行。finally块中的return语句会覆盖之前的return结果</li>
<li>finalize：根据Java语言规范，JVM保证调用finalize函数之前，这个对象是不可达的，而且JVM不保证一定会调用该方法</li>
</ol>
</li>
<li>传递与引用<ol>
<li>首先可以确定的说：Java传递的是值的副本<ol>
<li>基本类型变量：传递的是变量值的副本；也就是说即使副本被改变，原始变量值不会变</li>
<li>对象类型变量：传递的是引用的副本；因为传递的是引用，则引用内容可能会改变；</li>
</ol>
</li>
</ol>
</li>
<li>算法复杂度的计算：<ol>
<li>时间复杂度</li>
<li>空间复杂福</li>
</ol>
</li>
<li>JVM详解<ol>
<li>Java引用的四种状态<ol>
<li>强引用：new出来的对象，处于堆内存中，指向它的引用在栈中（内存空间不足，也不回收）</li>
<li>软引用：（内存空间足，不回收；不足，可能会随时被回收）常用来实现内存敏感的高速缓存</li>
<li>弱引用：每次Gc时，一旦发现有弱引用对象，不管内存是否足，都会回收</li>
<li>虚引用：类似于没有任何引用一样，在任何时候都可能会被回收；主要用于跟踪对象呗垃圾回收器回收的活动</li>
</ol>
</li>
<li>Java中内存的划分<ol>
<li>程序计数器：保证线程切换后能恢复到原来的执行位置 （线程私有）</li>
<li>jvm虚拟机栈：栈内存，为java方法服务，方法为调用 创建栈帧—&gt;局部变量表—&gt;局部变量，对象的引用，动态链接，方法出口灯（线程私有）（StackOverFlowError、OutOfMemoryError）</li>
<li>本地方法栈：为虚拟机运行使用到的Native方法服务（线程私有）（StackOverFlowError、OutOfMemoryError）</li>
<li>堆内存：存放所有new出来的对象（线程共享）（OutOfMemoryError）</li>
<li>方法区：存储被虚拟机JVM加载进来的类信息，常量，静态常量，静态方法等；（线程共享）</li>
<li>字符串常量池：方法区的一部分（线程共享）（OutOfMemoryError），一个由数组组成的表constant_pool[]用于存放Class，String以及基本类型的数据</li>
<li>补充：1，2，3这三个内存区域伴随线程，不需要考虑回收，线程结束，该区域自动会被回收；堆、方法区是Gc的主要战场，这里的内存分配是动态的</li>
<li>例子：String str = new String（“abc”）；创建了2个对象，一个在编译期创建“abc”，一个在运行期由new创建</li>
</ol>
</li>
<li>对象在内存中的状态<ol>
<li>可到达：自创建后，被一个或多个变量引用，则可达；从根节点上可触及到这个对象（引用链）</li>
<li>可恢复：对象不再被任何变量引用就进入了可恢复状态，回收该对象之前，会先调用finalize()方法，如果有重新有变量引用，则可达；</li>
<li>不可达：　Java对象不被任何变量引用，且系统在调用对象的finalize()方法后依然没有使该对象变成可达状态（该对象依然没有被变量引用），那么该对象将变成不可达状态。当Java对象处于不可达状态时，系统才会真正回收该对象所占有的资源。</li>
</ol>
</li>
<li>判断对象死亡的两种常用算法<ol>
<li>引用计数法：给对象增加一个引用计数器，0&lt;，则有引用；0&gt;，则无变量引用<ol>
<li>优点：算法简单，判断效率高</li>
<li>缺点：很难解决对象之间相互循环引用的问题</li>
</ol>
</li>
<li>根搜索算法：（当前采用）<ol>
<li>设立若干种root对象，当任何一个root对象到某个对象不可达时，则认为该对象可以被回收</li>
<li>root对象：<ol>
<li>栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区的静态变量</li>
<li>方法区中的常量引用的变量</li>
<li>本地方法栈中的JNI（Native方法）引用的对象</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>垃圾回收算法<ol>
<li>标记-清除：<ol>
<li>标记阶段：标记那些从根节点开始可到达的对象，未标记的则是待回收对象</li>
<li>清楚阶段：清除未标记的对象</li>
<li>优缺点：<ol>
<li>标记-清除效率不高，都需要从头遍历到尾，会产生大量的不连续内存碎片</li>
</ol>
</li>
</ol>
</li>
<li>复制：新生代gc<ol>
<li>将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，然后清除正在使用的内存块中的所有对象。</li>
<li>优点：<ol>
<li>不用考虑内存碎片，只需要移动堆顶指针，按顺序分配内存即可，简单效率高</li>
</ol>
</li>
<li>缺点：<ol>
<li>空间浪费</li>
</ol>
</li>
<li>补充：现在的商业虚拟机都采用这种收集算法来回收新生代，新生代中的对象98%都是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块比较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。</li>
<li>当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖于老年代进行分配担保，所以大对象直接进入老年代。</li>
</ol>
</li>
<li>标记-整理：老年代的gc<ol>
<li>标记阶段：标记从根节点开始的可达对象</li>
<li>整理阶段：将所有可达对象压缩到内存的一端，之后清理边界外的所有空间</li>
<li>优点：<ol>
<li>不产生内存碎片</li>
</ol>
</li>
<li>缺点：<ol>
<li>在标记的基础上，还需要进行对象的移动，成本相对较高，效率也不高</li>
</ol>
</li>
</ol>
</li>
<li>分代收集算法（当前采用）<br> 1. </li>
</ol>
</li>
<li>垃圾回收器<ol>
<li>Serial收集器：Client模式下的新生代收集器</li>
<li>Serial old收集器：client模式下的老年代收集器</li>
<li>ParallNew收集器：server模式下的首选新生代收集器</li>
<li>G1收集器：更加关注停顿时间</li>
<li>CMS收集器：并发标记清除，获取最短回收停顿时间为目标，老年代收集器</li>
</ol>
</li>
<li>堆内存划分<ol>
<li>新生代</li>
<li>老年代</li>
<li>永久代</li>
</ol>
</li>
<li>MinorGc ，FullGc</li>
<li>类加载机制<ol>
<li>过程：</li>
<li>类加载器</li>
<li>双亲委派模型</li>
</ol>
</li>
</ol>
</li>
<li>内存泄漏/缓存</li>
<li>数据结构与排序/查找：<ol>
<li><ol>
<li>链表</li>
<li>栈</li>
<li>堆</li>
<li>数组</li>
<li>树：<ol>
<li>二叉树（前序，中序，后序），</li>
<li>平衡二叉树：</li>
<li>红黑树</li>
</ol>
</li>
<li>图：<ol>
<li>深度优先遍历：（有些类似二叉树的前序遍历）</li>
<li>广度优先遍历：（有些类似二叉树的按层次遍历）</li>
</ol>
</li>
<li>实现搜索引擎的搜索建议的后台技术所采用的数据结构：<ol>
<li>字典树，一种哈希树的变种，快速检索的多叉树。典型用于统计和排序大量的字符串等文本词频</li>
<li>减少无谓的字符串比较，</li>
<li>空间换取时间</li>
</ol>
</li>
</ol>
</li>
<li>排序：<ol>
<li>气泡排序</li>
<li>插入排序</li>
<li>二叉树排序</li>
<li>选择排序</li>
<li>堆排序</li>
<li>快速排序</li>
<li>交换排序</li>
<li>补充：<ol>
<li>记录规模较小时，n《50，可采用直接插入或直接选择排序；相反n》50，应该采用时间复杂度为O（nlogn）的排序：快速排序，堆排序</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>反射与泛型：<ol>
<li>泛型：泛型的本质就是参数化类型；这种参数类型可用在接口，类，方法的创建中，分别称为泛型接口，泛型类，泛型方法</li>
</ol>
</li>
<li>枚举：Java1.5开始支持，java.lang.Enum为抽象类<ol>
<li>对Set和Map也提供支持：EnumSet EnumMap</li>
<li>枚举类中：常量，属性，构造方法，普通方法，抽象方法等</li>
<li>通过编译，生成抽象类并继承Enum，常量—&gt;final，静态$VALUES[]保存所定义的所有枚举常量；每一个定义的常量都会生成一个final内部类，里面的属性和大部分方法都是final的，通过静态代码块进行初始化，保证了枚举不可变性，不能clone，Serilizable等。</li>
<li>由3的产生中间类代码，可以知道：Enum相对于静态字符串常量占用的内存是比较大的</li>
</ol>
</li>
<li>动态代理：<ol>
<li></li>
</ol>
</li>
</ol>

      
    </div>
    
    
    

    <div>
      
        
      
    </div>

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/工具篇/git的常用场景/" rel="next" title="git的常用场景">
                <i class="fa fa-chevron-left"></i> git的常用场景
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/android开发/Android开发需要知道gradle的常用知识/" rel="prev" title="Android开发需要知道gradle的常用知识">
                Android开发需要知道gradle的常用知识 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div class="ds-thread" data-thread-key="java基础篇/java的常用知识整理/"
           data-title="Java的常用知识整理" data-url="http://wenchaos.com/java基础篇/java的常用知识整理/">
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="wenchaos" />
            
              <p class="site-author-name" itemprop="name">wenchaos</p>
              <p class="site-description motion-element" itemprop="description">湖人总冠军</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/iwenchao" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wenchaos</span>

  
</div>










        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"iwenchaos"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  


















  





  

  

  

  
  

  

  

  

</body>
</html>
