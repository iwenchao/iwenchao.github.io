<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大王派我来巡山</title>
  
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wenchaos.com/"/>
  <updated>2019-08-12T14:14:18.030Z</updated>
  <id>http://wenchaos.com/</id>
  
  <author>
    <name>wenchaos</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://wenchaos.com/%E5%B7%A5%E5%85%B7%E7%AF%87/md%E6%97%A5%E5%B8%B8%E8%AF%AD%E6%B3%95/"/>
    <id>http://wenchaos.com/工具篇/md日常语法/</id>
    <published>2019-08-12T14:14:02.598Z</published>
    <updated>2019-08-12T14:14:18.030Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mergeExtDexDebug出现的问题</title>
    <link href="http://wenchaos.com/%E9%97%AE%E9%A2%98%E5%86%8C/mergeExtDexdebugFail/"/>
    <id>http://wenchaos.com/问题册/mergeExtDexdebugFail/</id>
    <published>2019-04-06T16:00:00.000Z</published>
    <updated>2019-07-28T14:25:39.963Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="android" scheme="http://wenchaos.com/categories/android/"/>
    
    
      <category term="问题册" scheme="http://wenchaos.com/tags/%E9%97%AE%E9%A2%98%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>android中侧边栏的使用剖析</title>
    <link href="http://wenchaos.com/android%E5%BC%80%E5%8F%91/android%E4%B8%AD%E4%BE%A7%E8%BE%B9%E6%A0%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%89%96%E6%9E%90/"/>
    <id>http://wenchaos.com/android开发/android中侧边栏的使用剖析/</id>
    <published>2019-03-04T16:00:00.000Z</published>
    <updated>2019-07-27T02:21:40.035Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="笔记" scheme="http://wenchaos.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="android" scheme="http://wenchaos.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android-support库迁移到androidx</title>
    <link href="http://wenchaos.com/%E9%97%AE%E9%A2%98%E5%86%8C/android-support%E7%89%88%E6%9C%AC%E8%BF%81%E7%A7%BB%E5%88%B0androidx/"/>
    <id>http://wenchaos.com/问题册/android-support版本迁移到androidx/</id>
    <published>2019-03-04T16:00:00.000Z</published>
    <updated>2019-07-28T08:53:28.797Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="android" scheme="http://wenchaos.com/categories/android/"/>
    
    
      <category term="问题册" scheme="http://wenchaos.com/tags/%E9%97%AE%E9%A2%98%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>multiDex的由来</title>
    <link href="http://wenchaos.com/android%E5%BC%80%E5%8F%91/multiDex%E7%9A%84%E7%94%B1%E6%9D%A5/"/>
    <id>http://wenchaos.com/android开发/multiDex的由来/</id>
    <published>2019-01-01T16:00:00.000Z</published>
    <updated>2019-07-28T14:05:52.590Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android接入ffmpeg的介绍</title>
    <link href="http://wenchaos.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/android%E6%8E%A5%E5%85%A5ffmpeg%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <id>http://wenchaos.com/音视频基础/android接入ffmpeg的介绍/</id>
    <published>2018-10-08T16:00:00.000Z</published>
    <updated>2019-07-28T07:54:07.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h3><ol><li>JNI</li><li>CPU架构</li><li>交叉编译</li><li>NDK</li><li>ffmpeg相关</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h3 id=&quot;必备知识&quot;&gt;&lt;a href=&quot;#必备知识&quot; class=&quot;headerlink&quot; title=&quot;必备知识&quot;&gt;&lt;/a&gt;必备知识&lt;/h
      
    
    </summary>
    
      <category term="android，ffmpeg" scheme="http://wenchaos.com/categories/android%EF%BC%8Cffmpeg/"/>
    
    
      <category term="音视频" scheme="http://wenchaos.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>ffmepg中的日志操作</title>
    <link href="http://wenchaos.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/FFmpeg/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    <id>http://wenchaos.com/音视频基础/FFmpeg/日志系统/</id>
    <published>2018-08-16T16:00:00.000Z</published>
    <updated>2019-07-28T07:53:33.192Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="ffmpeg" scheme="http://wenchaos.com/categories/ffmpeg/"/>
    
    
      <category term="ffmpeg" scheme="http://wenchaos.com/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>java的并发基础剖析</title>
    <link href="http://wenchaos.com/java%E5%B9%B6%E5%8F%91/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%E5%89%96%E6%9E%90/"/>
    <id>http://wenchaos.com/java并发/java并发基础部分剖析/</id>
    <published>2018-07-20T16:00:00.000Z</published>
    <updated>2019-07-30T23:31:32.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为常用java语言开发的从业人员，怎么能不了解java的并发呢？那么我们一点一点开始讲起。</p><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p>首先从进程与线程讲起，那么两者的异同点如下</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。（进程是资源分配的最小单位）</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）</p><h3 id="进程与线程的生命周期"><a href="#进程与线程的生命周期" class="headerlink" title="进程与线程的生命周期"></a>进程与线程的生命周期</h3><p>线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。</p><ul><li>创建：新创建了一个线程对象。</li><li>就绪：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。</li><li>运行：就绪状态的线程获取了CPU，执行程序代码。</li><li>阻塞<ul><li>等待阻塞：运行的线程执行wait(),JVM会把该线程放入等待池中（wait()会释放掉持有的锁）</li><li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</li><li>其他阻塞： 运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）</li></ul></li><li>终止：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li></ul><h3 id="线程优先级："><a href="#线程优先级：" class="headerlink" title="线程优先级："></a>线程优先级：</h3><ol><li>Java线程有优先级，优先级高的线程会获得较多的运行机会</li><li>优先级用整数表示，取值范围是1~10；<ol><li>MAX_PRIORITY：10 </li><li>NORM_PRIORITY：5</li><li>MIN_PRIORITY：1</li></ol></li></ol><h1 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h1><p>有一些关键方法，理解这些关键方法对理解线程有很大的帮助。</p><h3 id="线程sleep："><a href="#线程sleep：" class="headerlink" title="线程sleep："></a>线程sleep：</h3><p>Thread类方法；使线程转到阻塞状态；睡眠结束后，就转为就绪（Runnable）状态。<strong><em>\</em>不会释放持有的锁，只是让出了cpu时间**</strong></p><h3 id="线程wait："><a href="#线程wait：" class="headerlink" title="线程wait："></a>线程wait：</h3><p>Object类方法；导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法<strong><em>\</em>立即释放**</strong>对象监视器，notify()/notifyAll()方法则会<strong><em>\</em>等待线程剩余代码执行完毕**</strong>才会放弃对象监视器。</p><h3 id="线程yield："><a href="#线程yield：" class="headerlink" title="线程yield："></a>线程yield：</h3><p>Thread类方法。<strong><em>\</em>暂停**</strong>当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。</p><h3 id="线程join："><a href="#线程join：" class="headerlink" title="线程join："></a>线程join：</h3><p>Thread.join()方法，当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个线程运行结束，当前线程再由阻塞转为就绪状态。</p><h3 id="线程唤醒notify，notifyAll："><a href="#线程唤醒notify，notifyAll：" class="headerlink" title="线程唤醒notify，notifyAll："></a>线程唤醒notify，notifyAll：</h3><p>Object类中的notify()方法，<strong>唤醒在此对象监视器上等待的单个线程</strong>。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。</p><h1 id="java中如何实现多线程"><a href="#java中如何实现多线程" class="headerlink" title="java中如何实现多线程"></a>java中如何实现多线程</h1><h3 id="三种方式，并与Future、线程池结合使用"><a href="#三种方式，并与Future、线程池结合使用" class="headerlink" title="三种方式，并与Future、线程池结合使用"></a>三种方式，并与Future、线程池结合使用</h3><ol><li><p>Thread父类</p></li><li><p>Runnable接口</p></li><li><p>Callable接口 （java 5新增） 有返回值</p></li></ol><h3 id="实现Runnable接口相比继承Thread类有如下优势："><a href="#实现Runnable接口相比继承Thread类有如下优势：" class="headerlink" title="实现Runnable接口相比继承Thread类有如下优势："></a>实现Runnable接口相比继承Thread类有如下优势：</h3><ol><li><p>避免单继承带来的局限</p></li><li><p>增强代码的健壮性，代码能够被多个程序共享，代码与数据时独立的</p></li><li><p>合适多个相同程序代码的线程区处理同一资料的情况</p></li></ol><h1 id="线程安全与共享资源"><a href="#线程安全与共享资源" class="headerlink" title="线程安全与共享资源"></a>线程安全与共享资源</h1><p>允许被多个线程同时执行的代码称作线程安全的代码。线程安全的代码<strong><em>\</em>不包含竞态条件**</strong>。当多个线程同时更新共享资源时会引发竞态条件。<strong>因此，了解Java线程执行时共享了什么资源很重要</strong>。</p><ol><li><p>局部变量：</p><ol><li>局部变量存储在线程自己的栈中。也就是说，局部变量永远也不会被多个线程共享</li><li>基础类型的局部变量是线程安全的</li><li>引用类型的局部变量：如果在某个方法中创建的对象不会逃逸出该方法，即该对象既不会被其他方法获得，也不会被非局部变量引用，那么认为它是线程安全的。</li></ol></li><li><p>成员对象</p><ol><li>对象成员存储在堆上</li><li>如果两个线程同时更新同一个对象实例的同一个成员，那这个代码就不是线程安全的。</li></ol></li><li><p>线程控制逃逸规则：判断某些资源的访问是否线程安全</p><ol><li>如果一个资源的创建，使用，销毁都在同一个线程内完成，且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。</li></ol></li></ol><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h5 id="可中断锁Lock"><a href="#可中断锁Lock" class="headerlink" title="可中断锁Lock"></a>可中断锁Lock</h5><ol><li><p>ReenterantLock：可重入锁，</p></li><li><p>ReadWriteLock:一个用来获取读锁，一个用来获取写锁。也就是说，将对临界资源的读写操作分成两个锁来分配给线程，从而使得多个线程可以同时进行读操作。</p></li><li><p>ReentrantReadWriteLock：可重入锁，</p></li></ol><h5 id="不可中断锁synchronized"><a href="#不可中断锁synchronized" class="headerlink" title="不可中断锁synchronized"></a>不可中断锁synchronized</h5><ol><li>synchronized：不可中断锁<ol><li>Java中的同步块用synchronized标记。同步块在Java中是同步在某个对象上。所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。</li><li>实例方法：同步在拥有该方法的实例对象上。</li><li>静态方法：同步在该方法所在的类对象上。</li><li>实例方法中的同步块：在同步构造器中用括号括起来的对象叫做<strong><em>\</em>监视器对象**</strong>。使用监视器对象同步，同步实例方法使用调用方法本身的实例this作为监视器对象。一次只有一个线程能够在同步于同一个监视器对象的Java方法内执行。如果一个在this，另一个不在this，那么两个方法可以被线程同时执行。</li><li>静态方法中的同步块：同步在该方法所属的Class类对象上。等同于静态方法添加synchronized修饰，不可以同时被两个线程访问</li></ol></li></ol><h5 id="lock与synchronized的异同点"><a href="#lock与synchronized的异同点" class="headerlink" title="lock与synchronized的异同点"></a>lock与synchronized的异同点</h5><ol><li>Lock是一个接口，是JDK层面的实现；而synchronized是Java中的关键字，是Java的内置特性，是JVM层面的实现；</li><li>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li><li>Lock 可以让等待锁的线程响应中断，而使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li><li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到；</li></ol><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>待补充！</p><h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><p>目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号。</p><h3 id="方式有哪些？"><a href="#方式有哪些？" class="headerlink" title="方式有哪些？"></a>方式有哪些？</h3><ol><li><p>共享对象： 即<strong>java的内存模型 JMM</strong></p></li><li><p>忙等待</p></li><li><p>wait()； notify()； notifyAll()；</p><ol><li>Java有一个内建的等待机制来允许线程在等待信号的时候变为非运行状态。java.lang.Object 类定义了三个方法，wait()、notify()和notifyAll()来实现这个等待机制。</li><li>一个线程一旦调用了任意对象的wait()方法，就会变为非运行状态，直到另一个线程调用了同一个对象的notify()方法。为了调用wait()或者notify()，线程必须先获得那个对象的锁。也就是说，<strong><em>\</em>线程必须在同步块里调用wait()或者notify()**</strong></li><li>当一个线程调用一个对象的notify()方法，正在等待该对象的所有线程中将有一个线程被唤醒并允许执行（校注：这个将被唤醒的线程是随机的，不可以指定唤醒哪个线程）。同时也提供了一个notifyAll()方法来唤醒正在等待一个给定对象的所有线程。</li><li>如你所见，不管是等待线程还是唤醒线程都在同步块里调用wait()和notify()。这是强制性的！一个线程如果没有持有对象锁，将不能调用wait()，notify()或者notifyAll()。否则，会抛出IllegalMonitorStateException异常。</li><li>一旦线程调用了wait()方法，它就释放了所持有的监视器对象上的锁。这将允许其他线程也可以调用wait()或者notify()。</li><li>一旦一个线程被唤醒，不能立刻就退出wait()的方法调用，直到调用notify()的线程退出了它自己的同步块。换句话说：被唤醒的线程必须重新获得监视器对象的锁，才可以退出wait()的方法调用，因为wait方法调用运行在同步块里面。如果多个线程被notifyAll()唤醒，那么在同一时刻将只有一个线程可以退出wait()方法，因为每个线程在退出wait()前必须获得监视器对象的锁。</li></ol></li><li>几个重要的方法<ol><li>sleep()方法是线程类（Thread）的静态方法，导致此线程暂停执行指定时间，将执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复（线程回到就绪（ready）状态），因为调用sleep 不会释放对象锁。</li><li>wait()是Object 类的方法，对此对象调用wait()方法导致本线程放弃对象锁(线程暂停执行)，进入等待此对象的等待锁定池，只有针对此对象发出notify 方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入就绪状态。</li><li>join方法用线程实例对象调用，如果在一个线程A中调用另一个线程B的join方法，线程A将会等待线程B执行完毕后再执行。</li><li>yield()可以直接用Thread类调用，yield()让出CPU执行权给同等级的线程，如果没有相同级别的线程在等待CPU的执行权，则该线程继续执行。</li></ol></li></ol><h6 id="问题：为何这三个不是Thread类声明中的方法，而是Object类中声明的方法？"><a href="#问题：为何这三个不是Thread类声明中的方法，而是Object类中声明的方法？" class="headerlink" title="问题：为何这三个不是Thread类声明中的方法，而是Object类中声明的方法？"></a>问题：为何这三个不是Thread类声明中的方法，而是Object类中声明的方法？</h6><p>​        其实这个问题很简单，由于每个对象都拥有monitor（即锁），所以让当前线程等待某个对象的锁，当然应该通过这个对象来操作了。而不是用当前线程来操作，因为当前线程可能会等待多个线程的锁，如果通过线程来操作，就非常复杂了。</p><ol><li><p>丢失的信号</p><ol><li>针对notify()有一个问题：即通知信号的丢失，如果一个线程先于被通知线程调用wait()前调用了notify()，等待的线程将错过这个信号。这可能使等待线程永远在等待。</li><li>为了避免信号丢失， 用一个变量来保存是否被通知过。在notify前，设置自己已经被通知过。在wait后，设置自己没有被通知过，需要等待通知。</li></ol></li><li><p>假唤醒</p><ol><li>由于莫名其妙的原因，线程有可能在没有调用过notify()和notifyAll()的情况下醒来。这就是所谓的假唤醒（spurious wakeups）。无端端地醒过来了。然后也能够执行后续的操作。这可能导致你的应用程序出现严重问题。</li><li>为了防止假唤醒，保存信号的成员变量将在一个while循环里接受检查，而不是在if表达式里。这样的一个while循环叫做自旋锁（校注：这种做法要慎重，目前的JVM实现自旋会消耗CPU，如果长时间不调用doNotify方法，doWait方法会一直自旋，CPU会消耗太大）。被唤醒的线程会自旋直到自旋锁(while循环)里的条件变为false</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MonitorObject myMonitorObject = <span class="keyword">new</span> MonitorObject();</span><br><span class="line"><span class="keyword">boolean</span> wasSignalled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWait</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">       <span class="keyword">while</span>(!wasSignalled)&#123;</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">​                myMonitorObject.wait();</span><br><span class="line">              &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;...&#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">       <span class="comment">//clear signal and continue running.</span></span><br><span class="line">      wasSignalled = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">        wasSignalled = <span class="keyword">true</span>;</span><br><span class="line">        myMonitorObject.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//留意wait()方法是在while循环里，而不在if表达式里。如果等待线程没有收到信号就唤醒，wasSignalled变量将变为false,while循环会再执行一次，促使醒来的线程回到等待状态。</span></span><br></pre></td></tr></table></figure></li><li><p>多线程等待相同的信号</p><ol><li><p>如果你有多个线程在等待，被notifyAll()唤醒，但只有一个被允许继续执行，使用while循环也是个好方法。每次只有一个线程可以获得监视器对象锁，意味着只有一个线程可以退出wait()调用并清除wasSignalled标志（设为false）。</p></li><li><p>一旦这个线程退出doWait()的同步块，其他线程退出wait()调用，并在while循环里检查wasSignalled变量值。但是，这个标志已经被第一个唤醒的线程清除了，所以其余醒来的线程将回到等待状态，直到下次信号到来。</p></li></ol></li></ol><ol><li>不要对常量字符串或者全局对象调用wait()<ol><li>在空字符串作为锁的同步块(或者其他常量字符串)里调用wait()和notify()产生的问题是，<strong><em>\</em>JVM/编译器内部会把常量字符串转换成同一个对象**</strong>。这意味着，即使你有2个不同的MyWaitNotify实例，它们都引用了相同的空字符串实例。同时也意味着存在这样的风险：在第一个MyWaitNotify实例上调用doWait()的线程会被在第二个MyWaitNotify实例上调用doNotify()的线程唤醒。</li></ol></li></ol><p>管程 (英语：Monitors，也称为监视器) 是<strong><em>\</em>对多个工作线程实现互斥访问共享资源的对象或模块**</strong>。这些共享资源一般是硬件设备或一群变量。管程实现了在一个时间点，最多只有一个线程在执行它的某个子程序。与那些通过修改数据结构实现互斥访问的并发程序设计相比，管程很大程度上简化了程序设计。</p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><ol><li><p>死锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。</p></li><li><p>避免死锁</p><ol><li>加锁顺序：当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。</li><li>加锁时限： 按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁(译者注：并对这些锁做适当的排序)，但总有些时候是无法预知的。此时就需要另一个种方法：加时。在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。 高并发下，这种方式效率不高</li></ol></li><li><p>死锁检测： 主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。</p></li></ol><h3 id="java中的锁"><a href="#java中的锁" class="headerlink" title="java中的锁"></a>java中的锁</h3><ol><li>简单的锁 <ol><li>Lock.java 不可重入，因为存在自旋锁的原因。解决：增加对当前线程的判断，如果同一个线程，可以进入；否则等待</li><li>Reentrant.java  可以重入</li></ol></li></ol><h5 id="锁的可重入性"><a href="#锁的可重入性" class="headerlink" title="锁的可重入性"></a>锁的可重入性</h5><p>​        如果一个线程已经拥有了一个管程对象上的锁，那么它就有权访问被这个管程对象同步的所有代码块。这就是可重入。</p><p>​         Java中的synchronized同步块是可重入的。这意味着如果一个java线程进入了代码中的synchronized同步块，并因此获得了该同步块使用的同步对象对应的管程上的锁，那么这个线程可以进入由同一个管程对象所同步的另一个java代码块。</p><p>​        当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果摸个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是调用。</p><p>​        重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程所持有，当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1，如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁将被释放。</p><h5 id="锁的公平性"><a href="#锁的公平性" class="headerlink" title="锁的公平性"></a>锁的公平性</h5><p>​        synchronized块并不保证尝试进入它们的线程的顺序。因此可能出现线程饥饿现象。需要额外实现，保证公平性</p><p>​         在finally语句中调用unlock()</p><h5 id="饥饿与公平"><a href="#饥饿与公平" class="headerlink" title="饥饿与公平"></a>饥饿与公平</h5><ol><li>饥饿：如果一个线程因为CPU时间全部被其他线程抢走而得不到CPU运行时间，这种状态被称之为“饥饿”。<ol><li>原因：<ol><li>高优先级线程吞噬所有的低优先级线程的CPU时间。</li><li>线程被永久堵塞在一个等待进入同步块的状态。</li><li>线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的wait方法)。</li></ol></li><li>解决方式<ol><li>使用锁，而不是同步块</li><li>公平锁</li><li>注意性能方面</li><li><a href="http://ifeve.com/starvation-and-fairness/" target="_blank" rel="noopener">参考资料</a>   </li></ol></li></ol></li></ol><h5 id="嵌套管程死锁"><a href="#嵌套管程死锁" class="headerlink" title="嵌套管程死锁"></a>嵌套管程死锁</h5><p>死锁中，二个线程都在等待对方释放锁。</p><p>嵌套管程锁死中，线程1持有锁A，同时等待从线程2发来的信号，线程2需要锁A来发信号给线程1。</p><h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>Java5在java.util.concurrent包中已经包含了读写锁。</p><h5 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h5><p>Semaphore（信号量） 是一个线程同步结构，用于在线程间传递信号，以避免出现信号丢失（译者注：下文会具体介绍），或者像锁一样用于保护一个关键区域。自从5.0开始，jdk在java.util.concurrent包里提供了 Semaphore 的官方实现，因此大家不需要自己去实现Semaphore。但是还是很有必要去熟悉如何使用Semaphore及其背后的原理</p><ol><li>Semaphore的实现</li><li><p>使用Semaphore</p></li><li><p>可计数的Semaphore</p></li><li><p>有上限的Semaphore</p></li><li><p>把Semaphore当锁来使用</p></li></ol><h6 id="问题：-同步方法和同步块，哪个是更好的选择"><a href="#问题：-同步方法和同步块，哪个是更好的选择" class="headerlink" title="问题： 同步方法和同步块，哪个是更好的选择"></a>问题： 同步方法和同步块，哪个是更好的选择</h6><ol><li><p>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。</p></li><li><p>但是借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做<strong><em>\</em>锁粗化**</strong>的优化方法，<strong><em>\</em>这种方法就是把同步范围变大**</strong>。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。</p></li></ol><p>\1. 乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换CAS这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p><p>\2. 悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><ol><li><p>使用interrupt()中断线程：当一个线程运行时，另一个线程可以调用对应的Thread对象的interrupt（）方法来中断它，该方法只是在目标线程中设置一个标志，表示它已经被中断，并立即返回。这里需要注意的是，如果只是单纯的调用interrupt（）方法，线程并没有实际被中断，会继续往下执行</p></li><li><p>待决中断：如果线程在调用sleep（）方法前就被中断，那么该中断称为待决中断，它会在刚调用sleep（）方法时，立即抛出InterruptedException异常。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> public class PendingInterrupt extends Object&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​        public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">​            //如果输入了参数，则在main线程中中断当前线程（即main线程）</span><br><span class="line"></span><br><span class="line">​            if(args.length &gt; 0)&#123;</span><br><span class="line"></span><br><span class="line">​                Thread.currentThread().interrupt();</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​            //获取当前时间</span><br><span class="line"></span><br><span class="line">​            long startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">​            try &#123;</span><br><span class="line"></span><br><span class="line">​                Thread.sleep(2000);</span><br><span class="line"></span><br><span class="line">​                System.out.println(&quot;was NOT interrupted&quot;);</span><br><span class="line"></span><br><span class="line">​            &#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">​                System.out.println(&quot;was interrupted&quot;);</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​            //计算中间代码执行的时间</span><br><span class="line"></span><br><span class="line">​            System.out.println(&quot;elapsedTime=&quot; + (System.currentTimeMillis() - startTime));</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><p>这种模式下，main线程中断它自身。除了将中断标志（它是Thread的内部标志）设置为true外，没有其他任何影响。线程被中断了，但main线程仍然运行，main线程继续监视实时时钟，并进入try块，一旦调用sleep（）方法，它就会注意到待决中断的存在，并抛出InterruptException。于是执行跳转到catch块，并打印出线程被中断的信息。最后，计算并打印出时间差。</p><p>- 使用isInterrupted（）方法判断中断状态</p><p>可以在Thread实例对象上调用isInterrupted（）方法来检查任何线程的中断状态。这里需要注意：线程一旦被中断，isInterrupted（）方法便会返回true，而一旦sleep（）方法抛出异常，它将清空中断标志，此时isInterrupted（）方法将返回false。</p><p>- 使用Thread.interrupted（）方法判断中断状态</p><p>可以使用Thread.interrupted（）方法来检查当前线程的中断状态（并隐式重置为false）。又由于它是静态方法，因此不能在特定的线程上使用，而只能报告调用它的线程的中断状态，如果线程被中断，而且中断状态尚不清楚，那么，这个方法返回true。与isInterrupted（）不同，它将自动重置中断状态为false，第二次调用Thread.interrupted（）方法，总是返回false，除非中断了线程。</p><h3 id="守护线程与阻塞线程"><a href="#守护线程与阻塞线程" class="headerlink" title="守护线程与阻塞线程"></a>守护线程与阻塞线程</h3><ol><li><p>用户线程：即运行在前台的线程</p></li><li><p>守护线程：是运行在后台的线程</p><ol><li>守护线程作用是为其他前台线程的运行提供便利服务，而且仅在普通、非守护线程仍然运行时才需要，比如垃圾回收线程就是一个守护线程。当VM检测仅剩一个守护线程，而用户线程都已经退出运行时，VM就会退出，因为如果没有了守护者，也就没有继续运行程序的必要了。如果有非守护线程仍然活着，VM就不会退出。</li><li>守护线程并非只有虚拟机内部提供，用户在编写程序时也可以自己设置守护线程。用户可以用Thread的setDaemon(true)方法设置当前线程为守护线程。</li><li>setDaemon(true)必须在调用线程的start()方法之前设置，否则会跑出IllegalThreadStateException异常。</li><li>在守护线程中产生的新线程也是守护线程</li><li>不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。</li></ol></li></ol><ol><li>线程阻塞：<ol><li>（可中断）当线程执行Thread.sleep()时，它一直阻塞到指定的毫秒时间之后，或者阻塞被另一个线程打断</li><li>（可中断）当线程碰到一条wait()语句时，它会一直阻塞到接到通知(notify())、被中断或经过了指定毫秒 时间为止(若指定了超时值的话)</li><li>线程阻塞与不同的I/O的方式有多种。常见的一种方式是InputStream的read()方法，该方法一直阻塞到从流中读取一个字节的数据为止，它可以无限阻塞，因此不能指定超时时间</li><li>线程也可以阻塞等待获取某个对象锁的排它性访问权限(即等待获得synchronized语句必须的锁时阻塞)</li></ol></li></ol><h3 id="多线程环境中安全使用集合API"><a href="#多线程环境中安全使用集合API" class="headerlink" title="多线程环境中安全使用集合API"></a>多线程环境中安全使用集合API</h3><p>- public static Collection synchronizedCollention(Collection c)</p><p>- public static List synchronizedList(list l)</p><p>- public static Map synchronizedMap(Map m)</p><p>- public static Set synchronizedSet(Set s)</p><p>- public static SortedMap synchronizedSortedMap(SortedMap sm)</p><p>- public static SortedSet synchronizedSortedSet(SortedSet ss)</p><h3 id="并发编程中实现内存可见的两种方法比较：加锁synchronized和volatile变量"><a href="#并发编程中实现内存可见的两种方法比较：加锁synchronized和volatile变量" class="headerlink" title="并发编程中实现内存可见的两种方法比较：加锁synchronized和volatile变量"></a>并发编程中实现内存可见的两种方法比较：加锁synchronized和volatile变量</h3><ol><li>volatile变量是一种稍弱的同步机制在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。</li></ol><ol><li>从<strong><em>\</em>内存可见性**</strong>的角度看，写入volatile变量相当于退出同步代码块，而读取volatile变量相当于进入同步代码块。</li></ol><ol><li>在代码中如果过度依赖volatile变量来控制状态的可见性，通常会比使用锁的代码更脆弱，也更难以理解。仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它。一般来说，用同步机制会更安全些。</li></ol><ol><li>加锁机制（即同步机制）<strong><em>\</em>既可以确保可见性又可以确保原子性**</strong>，而<strong><em>\</em>volatile变量只能确保可见性**</strong>，原因是声明为volatile的简单变量如果当前值与该变量以前的值相关，那么volatile关键字不起作用，也就是说如下的表达式都<strong><em>\</em>不是原子操作**</strong>：“count++”、“count = count+1”。<ol><li>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</li><li>该变量没有包含在具有其他变量的不变式中。</li></ol></li></ol><p>总结：在需要同步的时候，第一选择应该是synchronized关键字，这是最安全的方式，尝试其他任何方式都是有风险的。尤其在、jdK1.5之后，对synchronized同步机制做了很多优化，如：自适应的自旋锁、锁粗化、锁消除、轻量级锁等，使得它的性能明显有了很大的提升。</p><h1 id="引入NIO"><a href="#引入NIO" class="headerlink" title="引入NIO"></a>引入NIO</h1><p>从Java1.4开始，引入NIO，提供了与标准IO不同的IO工作方式。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>​    - 标准io：基于字节流和字符流进行操作的</p><p>​    - NIO：基于通道(Channel)和缓冲区(Buffer)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入通道也类似。</p><h3 id="核心组成"><a href="#核心组成" class="headerlink" title="核心组成"></a>核心组成</h3><ol><li>NIO由以下核心部分组成：</li></ol><p>​            - Channels：</p><p>​                - Channel有点像流。数据可以从Channel读到Buffer中，也可以从Buffer写到Channel中。但流的读写通常是单向的。</p><p>​                - 通道可以异步的读写。</p><p>​                - 通道的数据总是要先读到一个Buffer，或者总要从一个Buffer中写入。</p><p>​                - FileChannel 从文件中读取数据</p><p>​                - DatagramChannel  能通过UDP读写网络中的数据</p><p>​                - SocketChannel 能通过TCP读写网络中的数据</p><p>​                - ServerSocketChannel 可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel</p><p>​            - Buffers</p><p>​                - ByteBuffer</p><p>​                - CharBuffer</p><p>​                - DoubleBuffer</p><p>​                - FloatBuffer</p><p>​                - IntBuffer</p><p>​                - LongBuffer</p><p>​                - ShortBuffer</p><p>​                - MappedByteBuffer，用于表示内存映射文件</p><p>​            - Selectors：Selector允许单线程处理多个Channel</p><ol><li><p>nio：Non-blocking IO（非阻塞IO）。Java NIO可以让你非阻塞的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。</p></li><li><p>Java NIO: Selectors(选择器)。Java NIO引入了选择器的概念，选择器用于监听多个通道的事件(比如：连接打开，数据到达)。因此，单个的线程可以监听多个数据通道。</p></li></ol><p>#课后练习</p><h6 id="1-写出生产者消费者模式"><a href="#1-写出生产者消费者模式" class="headerlink" title="1. 写出生产者消费者模式"></a>1. 写出生产者消费者模式</h6><h6 id="2-Concurrent包里的其他东西：ArrayBlockingQueue-CountDownLatch"><a href="#2-Concurrent包里的其他东西：ArrayBlockingQueue-CountDownLatch" class="headerlink" title="2. Concurrent包里的其他东西：ArrayBlockingQueue  CountDownLatch"></a>2. Concurrent包里的其他东西：ArrayBlockingQueue  CountDownLatch</h6><h6 id="3-阻塞队列实现，BlockingQueue"><a href="#3-阻塞队列实现，BlockingQueue" class="headerlink" title="3. 阻塞队列实现，BlockingQueue"></a>3. 阻塞队列实现，BlockingQueue</h6><h6 id="4-sync关键字实现，"><a href="#4-sync关键字实现，" class="headerlink" title="4.sync关键字实现，"></a>4.sync关键字实现，</h6><h6 id="5-lock实现，"><a href="#5-lock实现，" class="headerlink" title="5. lock实现，"></a>5. lock实现，</h6><h6 id="6-reentrantLock等"><a href="#6-reentrantLock等" class="headerlink" title="6. reentrantLock等"></a>6. reentrantLock等</h6><h1 id="实践建议"><a href="#实践建议" class="headerlink" title="实践建议"></a>实践建议</h1><ol><li><p>给你的线程起个有意义的名字，这样可以方便找bug或追踪。</p></li><li><p>根据具体的使用场景，选择锁定和缩小同步的范围（或小，或大（考虑StringBuffer append使用场景 就是用到锁粗化））</p></li><li><p>多用同步类少用wait 和 notify。CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。</p></li><li><p>多用并发集合少用同步集合</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;作为常用java语言开发的从业人员，怎么能不了解java的并发呢？那么我们一点一点开始讲起。&lt;/p&gt;
&lt;h1 id=&quot;进程与线程&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="java" scheme="http://wenchaos.com/categories/java/"/>
    
    
      <category term="java" scheme="http://wenchaos.com/tags/java/"/>
    
      <category term="并发" scheme="http://wenchaos.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java后端搭建初稿</title>
    <link href="http://wenchaos.com/java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%90%8E%E7%AB%AF%E6%90%AD%E5%BB%BA%E5%88%9D%E7%A8%BF/"/>
    <id>http://wenchaos.com/java后端开发/java后端搭建初稿/</id>
    <published>2018-06-08T16:00:00.000Z</published>
    <updated>2019-07-28T07:55:25.082Z</updated>
    
    <content type="html"><![CDATA[<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ol><li>java基础知识</li><li>Servlet与jsp基础知识</li><li>Spring+SpringMVC+Mybatis使用</li><li>Redis使用</li></ol><h3 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h3><ol><li>intellij idea：ide</li><li>tomcat或者jetty：server容器</li><li>Navicat premiun:管理数据库</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;java基础知识&lt;/li&gt;
&lt;li&gt;Servlet与jsp基础知识&lt;/li&gt;
&lt;li&gt;Spring+Spring
      
    
    </summary>
    
      <category term="后端开发" scheme="http://wenchaos.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java，后端开发" scheme="http://wenchaos.com/tags/java%EF%BC%8C%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java中涉及到的基本设计原则与模式</title>
    <link href="http://wenchaos.com/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%B6%E6%9E%84/java%E4%B8%AD%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://wenchaos.com/设计与架构/java中涉及到的基本设计原则/</id>
    <published>2018-06-04T16:00:00.000Z</published>
    <updated>2019-09-11T15:26:47.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在日常的开发中总会遇到各种各样的情景。那么在实践中如果像流水账一样的将一个模块代码写下来，恐怕过一阵子你都忍受不了。所以学习一下开发中用到的常见设计规则，是非常有用的。这些原则会不知不觉的指导你开发出好看的代码。</p><h2 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h2><h3 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1.单一职责原则"></a>1.单一职责原则</h3><p>就是一个类只负责一件事情。并且需要考虑全面，尽可能将这件事情做到极致，简洁，高效，健壮。这样的话，就可以进一步实现解耦合的效果，让代码清晰，同时也体现了java中的封装特性。。</p><h3 id="2-迪米特原则"><a href="#2-迪米特原则" class="headerlink" title="2.迪米特原则"></a>2.迪米特原则</h3><p>就是一个类对另一个类有尽可能的了解，这里就指的是解耦合的事情。</p><h3 id="3-里氏替换原则和依赖倒置原则"><a href="#3-里氏替换原则和依赖倒置原则" class="headerlink" title="3.里氏替换原则和依赖倒置原则"></a>3.里氏替换原则和依赖倒置原则</h3><p>说的是java中的继承特性。父类可以做的事情，子类都可以去做，子类可以尽量依赖父类去做事情，即子类可以尽可能的依赖父类去做事情。但是反过来，父类不能依赖子类去做事情；</p><h3 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4.接口隔离原则"></a>4.接口隔离原则</h3><p>接口也应该尽可能的隔离开。其实类写多了，确实可以做到耦合性低，为了让它们交流起来，用的最多的是<strong>接口</strong>。因为我们只需要知道做什么，至于怎么做就交给具体的类吧。</p><h3 id="5-开闭原则"><a href="#5-开闭原则" class="headerlink" title="5.开闭原则"></a>5.开闭原则</h3><p>对修改关闭，对扩展开放。这里说的就是对代码要有良好的延展性，对原有代码不能有结构性的破坏。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h3><p>单例模式有很多形式，其中有两个我常用到的。一个是两重判断，另一个是静态内部类常量的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">private static Singleton INSTANCE;</span><br><span class="line">private Singleton()&#123;&#125;</span><br><span class="line">//推荐，只在没有实例化的时候，加锁</span><br><span class="line">public static Singleton get()&#123;</span><br><span class="line">if(INSTANCE == null)&#123;</span><br><span class="line">synchronized(Singleton.class)&#123;</span><br><span class="line">if(INSTANCE ==  null)&#123;</span><br><span class="line">INSTANCE = new Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">//方式二，不推荐。因为不管有没有实例化，都会加锁访问，效率不高，会引起线程阻塞</span><br><span class="line">public static synchronized Singleton get() &#123;</span><br><span class="line">        if (INSTANCE == null) &#123;</span><br><span class="line">            INSTANCE = new Singleton1();</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    //方式三：加载一个类时，其内部类不会同时被加载。一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生。 由于在调用 StaticSingleton.getInstance() 的时候，才会对单例进行初始化，而且通过反射，是不能从外部类获取内部类的属性的；由于静态内部类的特性，只有在其被第一次引用的时候才会被加载，所以可以保证其线程安全性。 </span><br><span class="line">总结： </span><br><span class="line">优势：兼顾了懒汉模式的内存优化（使用时才初始化）以及饿汉模式的安全性（不会被反射入侵）。 </span><br><span class="line">劣势：需要两个类去做到这一点，虽然不会创建静态内部类的对象，但是其 Class 对象还是会被创建，而且是属于永久带的对象</span><br><span class="line">     public static StaticSingleton getInstance() &#123;</span><br><span class="line">        return StaticSingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 一个私有的静态内部类，用于初始化一个静态final实例</span><br><span class="line">     */</span><br><span class="line">    private static class StaticSingletonHolder &#123;</span><br><span class="line">        private static final StaticSingleton instance = new StaticSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-创建者模式"><a href="#2-创建者模式" class="headerlink" title="2.创建者模式"></a>2.创建者模式</h3><p>定义<strong>一个</strong>工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口。</p><p>使用场景：需要创建的对象少，客户端不关心对象创建过程。</p><h4 id="2-1-简单工厂模式"><a href="#2-1-简单工厂模式" class="headerlink" title="2.1 简单工厂模式"></a>2.1 简单工厂模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line"><span class="function">String <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"I am Cirle"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rect</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"I am Rect"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getShape</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line"><span class="comment">//安全性校验缺省</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">"circle"</span>.equals(type))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"rect"</span>.equals(type))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Rect();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中可以看到，简单工厂确实非常简单，但是也是弊端也非常明显。因为每次增加一个Shape，则需要在工程的getShape()方法中修改。</p><h4 id="2-2-工厂方法模式"><a href="#2-2-工厂方法模式" class="headerlink" title="2.2 工厂方法模式"></a>2.2 工厂方法模式</h4><p>工厂方法模式是简单工厂的仅一步深化， 在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是<strong>针对不同的对象提供不同的工厂。也就是说每个对象都有一个与之对应的工厂</strong>。</p><p>定义：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。</p><p>使用场景：例如现在需要设计一个这样的图片加载类，它具有多个图片加载器，用来加载jpg，png，gif格式的图片，每个加载器都有一个read（）方法，用于读取图片。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">增加一个读取图片的公共接口</span><br><span class="line">public interface Reader &#123;</span><br><span class="line">    void read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//jpg reader</span><br><span class="line">public class JpgReader implements Reader &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void read() &#123;</span><br><span class="line">        System.out.print(&quot;read jpg&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//png reader</span><br><span class="line">public class PngReader implements Reader &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void read() &#123;</span><br><span class="line">        System.out.print(&quot;read png&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//定义ReaderFactory</span><br><span class="line">public interface ReaderFactory &#123;</span><br><span class="line">    Reader getReader();</span><br><span class="line">&#125;</span><br><span class="line">//jpg reader 工厂</span><br><span class="line">public class JpgReaderFactory implements ReaderFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Reader getReader() &#123;</span><br><span class="line">        return new JpgReader();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//png reader 工厂</span><br><span class="line">public class PngReaderFactory implements ReaderFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Reader getReader() &#123;</span><br><span class="line">        return new PngReader();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">ReaderFactory factory=new JpgReaderFactory();</span><br><span class="line">Reader  reader=factory.getReader();</span><br><span class="line">reader.read();</span><br></pre></td></tr></table></figure><h4 id="2-3-抽象工厂模式"><a href="#2-3-抽象工厂模式" class="headerlink" title="2.3 抽象工厂模式"></a>2.3 抽象工厂模式</h4><p>这个模式最不好理解，而且在实际应用中局限性也蛮大的，因为这个模式并不符合开闭原则。实际开发还需要做好权衡。<br>抽象工厂模式是工厂方法的仅一步深化，主要是设计产品组以及工厂组的概念，在这个模式中的工厂类不单单可以创建一个对象，而是可以创建一组对象。这是和工厂方法最大的不同点。</p><h3 id="3-建造者模式"><a href="#3-建造者模式" class="headerlink" title="3. 建造者模式"></a>3. 建造者模式</h3><p>将一个复杂对象分步创建，如果一个超大的类的属性特别多。</p><h3 id="4-代理模式"><a href="#4-代理模式" class="headerlink" title="4. 代理模式"></a>4. 代理模式</h3><h4 id="4-1静态代理"><a href="#4-1静态代理" class="headerlink" title="4.1静态代理"></a>4.1静态代理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public interface IUserDao &#123;</span><br><span class="line">    void save();</span><br><span class="line">&#125;</span><br><span class="line">public class UserDao implements IUserDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;----已经保存数据!----&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class UserDaoProxy implements IUserDao&#123;</span><br><span class="line">    //接收保存目标对象</span><br><span class="line">    private IUserDao target;</span><br><span class="line">    public UserDaoProxy(IUserDao target)&#123;</span><br><span class="line">        this.target=target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;开始事务...&quot;);</span><br><span class="line">        target.save();//执行目标对象的方法</span><br><span class="line">        System.out.println(&quot;提交事务...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>可以做到在不修改目标对象的功能前提下,对目标功能扩展.</li><li>缺点:<br>　　代理类和委托类实现相同的接口，同时要实现相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。</li></ol><h4 id="4-2-动态代理"><a href="#4-2-动态代理" class="headerlink" title="4.2 动态代理"></a>4.2 动态代理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Object Proxy.newProxyInstance(ClassLoader loader, Class [] interfaces, InvocationHandler handler);</span><br><span class="line"></span><br><span class="line">注意该方法是在Proxy类中是静态方法,且接收的三个参数依次为:</span><br><span class="line"></span><br><span class="line">ClassLoader loader:指定当前目标对象使用类加载器,用null表示默认类加载器</span><br><span class="line"></span><br><span class="line">Class [] interfaces:需要实现的接口数组</span><br><span class="line"></span><br><span class="line">InvocationHandler handler:调用处理器,执行目标对象的方法时,会触发调用处理器的方法,从而把当前执行目标对象的方法作为参数传入</span><br><span class="line">java.lang.reflect.InvocationHandler：这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 创建动态代理对象</span><br><span class="line"> * 动态代理不需要实现接口,但是需要指定接口类型</span><br><span class="line"> */</span><br><span class="line">public class ProxyFactory&#123;</span><br><span class="line">    //维护一个目标对象</span><br><span class="line">    private Object target;</span><br><span class="line">    public ProxyFactory(Object target)&#123;</span><br><span class="line">        this.target=target;</span><br><span class="line">    &#125;</span><br><span class="line">    //给目标对象生成代理对象</span><br><span class="line">    public Object getProxyInstance()&#123;</span><br><span class="line">        return Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                new InvocationHandler() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                        System.out.println(&quot;开始事务2&quot;);</span><br><span class="line">                        //执行目标对象方法</span><br><span class="line">                        Object returnValue = method.invoke(target, args);</span><br><span class="line">                        System.out.println(&quot;提交事务2&quot;);</span><br><span class="line">                        return returnValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>在运行期，通过反射机制创建一个实现了一组给定接口的新类</p></li><li><p>在运行时生成的class，必须提供一组interface给它，然后该class就宣称它实现了这些 interface。该class的实 例可以当作这些interface中的任何一个来用。但是这个Dynamic Proxy其实就是一个Proxy， 它不会替你作实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工 作。</p></li><li><p>动态代理也叫做:JDK代理,接口代理</p></li><li><p>接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。而且动态代理的应用使我们的类职责更加单一，复用性更强</p></li><li><p>代理模式与装饰者模式的区别</p><p>　　UML类图基本没区别，都是实现同一个接口，一个类包装另一 个类。 两者的定义：</p><ul><li>装饰器模式：能动态的新增或组合对象的行为<br>在不改变接口的前提下，动态扩展对象的功能</li><li>代理模式：为其他对象提供一种代理以控制对这个对象的访问<br>在不改变接口的前提下，控制对象的访问</li><li>装饰模式是“新增行为”，而代理模式是“控制访问”。关键就是我们如何判断是“新增行 为”还是“控制访问”。你在一个地方写装饰，大家就知道这是在增加功能，你写代理，大 家就知道是在限制。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在日常的开发中总会遇到各种各样的情景。那么在实践中如果像流水账一样的将一个模块代码写下来，恐怕过一阵子你都忍受不了。所以学习一下开发中用到的
      
    
    </summary>
    
      <category term="java" scheme="http://wenchaos.com/categories/java/"/>
    
    
      <category term="设计原则，设计模式" scheme="http://wenchaos.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>c++是一门值得学习的语言呢</title>
    <link href="http://wenchaos.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c++%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://wenchaos.com/编程语言/c++语言入门总结/</id>
    <published>2018-05-08T16:00:00.000Z</published>
    <updated>2019-07-28T14:02:04.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文内容主要来自《C++ Primer Plus》</p><h1 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h1><h2 id="第一章摘要"><a href="#第一章摘要" class="headerlink" title="第一章摘要"></a>第一章摘要</h2><ol><li>面向过程与面向对象</li><li>几种c++编译器的使用方法</li></ol><h2 id="第二章摘要（无）"><a href="#第二章摘要（无）" class="headerlink" title="第二章摘要（无）"></a>第二章摘要（无）</h2><h2 id="第三章摘要"><a href="#第三章摘要" class="headerlink" title="第三章摘要"></a>第三章摘要</h2><ol><li>数据类型</li><li>数据类型之间的转换</li></ol><h2 id="第四章摘要"><a href="#第四章摘要" class="headerlink" title="第四章摘要"></a>第四章摘要</h2><ol><li>复合类型<ol><li>数组</li><li>结构</li><li>指针</li></ol></li><li>内存分配的一些方法</li></ol><h2 id="第五章摘要"><a href="#第五章摘要" class="headerlink" title="第五章摘要"></a>第五章摘要</h2><ol><li>循环 <ol><li>for</li><li>while</li><li>do while</li></ol></li><li>关系表达式</li></ol><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><ol><li>分支语句<ol><li>if else </li><li>switch</li></ol></li><li>逻辑运算符</li></ol><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><ol><li>函数<ol><li>c++和c函数的共同特性</li><li>函数定义</li><li>函数原型</li></ol></li><li>函数指针</li></ol><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><ol><li>c++中函数的新增特性<ol><li>内联函数</li></ol></li></ol><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><ol><li>内存模型</li><li>名称空间</li></ol><h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><ol><li>对象和类</li></ol><h2 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h2><ol><li>运算重载符</li></ol><h1 id="重点部分"><a href="#重点部分" class="headerlink" title="重点部分"></a>重点部分</h1><ol><li>类和对象</li><li>继承</li><li>多态，虚函数和RTTI（运行时类型识别）</li><li>函数重载</li><li>引用变量</li><li>泛型（独立于类型的）编程</li><li>处理错误的异常机制</li><li>管理函数，类和变量名的名称空间</li></ol><h1 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文内容主要来自《C++ Primer Plus》&lt;/p&gt;
&lt;h1 id=&quot;基础部分&quot;&gt;&lt;a href=&quot;#基础部分&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="c++" scheme="http://wenchaos.com/categories/c/"/>
    
    
      <category term="编程语言" scheme="http://wenchaos.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>同步与异步</title>
    <link href="http://wenchaos.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
    <id>http://wenchaos.com/计算机基础/同步与异步/</id>
    <published>2018-04-15T16:00:00.000Z</published>
    <updated>2019-07-28T07:54:46.703Z</updated>
    
    <content type="html"><![CDATA[<p>在讲到同步，异步，并发，并行，阻塞与非阻塞这些概念的时候，一定会涉及到进程与线程的相关概念。因此需要先了解一下进程与线程。</p><p>#进程与线程</p><ol><li>进程（Process）：具有独立功能的程序在某个数据集合上的一次运行活动；是OS进行资源分配和保护的基本单位。</li><li>线程（Thread）：</li><li>区别：<ol><li>进程是系统资源分配的基本单位，线程是cpu调度，程序执行的最小单位。</li><li>进程有独立的地址空间，而同一进程中的线程共享改进程的地址空间。</li><li>线程间通信</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在讲到同步，异步，并发，并行，阻塞与非阻塞这些概念的时候，一定会涉及到进程与线程的相关概念。因此需要先了解一下进程与线程。&lt;/p&gt;
&lt;p&gt;#进程与线程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程（Process）：具有独立功能的程序在某个数据集合上的一次运行活动；是OS进行资源分配和保
      
    
    </summary>
    
      <category term="java" scheme="http://wenchaos.com/categories/java/"/>
    
    
      <category term="并发" scheme="http://wenchaos.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github搭建个人博客攻略</title>
    <link href="http://wenchaos.com/%E5%B7%A5%E5%85%B7%E7%AF%87/hexo+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%94%BB%E7%95%A5/"/>
    <id>http://wenchaos.com/工具篇/hexo+github搭建博客攻略/</id>
    <published>2018-04-09T16:00:00.000Z</published>
    <updated>2019-05-06T15:24:04.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>随着国内开发者水平的提高，以及各个技术博客的平台相继出现。有些人更愿意将写的博客记录在自己的平台上，故而引出本文。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;随着国内开发者水平的提高，以及各个技术博客的平台相继出现。有些人更愿意将写的博客记录在自己的平台上，故而引出本文。&lt;/p&gt;

      
    
    </summary>
    
      <category term="工具，" scheme="http://wenchaos.com/categories/%E5%B7%A5%E5%85%B7%EF%BC%8C/"/>
    
    
      <category term="工具，hexo，github" scheme="http://wenchaos.com/tags/%E5%B7%A5%E5%85%B7%EF%BC%8Chexo%EF%BC%8Cgithub/"/>
    
  </entry>
  
  <entry>
    <title>c是一门值得学习的语言呢</title>
    <link href="http://wenchaos.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://wenchaos.com/编程语言/c语言入门总结/</id>
    <published>2018-04-08T16:00:00.000Z</published>
    <updated>2019-07-13T09:55:28.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="3。数据类型"><a href="#3。数据类型" class="headerlink" title="3。数据类型"></a>3。数据类型</h1><ol><li>2.<br>3.</li><li><p>实型数据（又称浮点类型）</p><ul><li>实型常量的表示方法<ol><li>小数形式</li><li>指数形式</li></ol></li><li>实型变量<ol><li>在内存中的存放形式<ul><li>一般占4个字节byte（32位）</li></ul></li><li>实型变量的分类<ol><li>单精度float：4个字节</li><li>双精度double：8个字节</li><li>长双精度long double: </li></ol></li></ol></li></ul></li><li><p>结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct st&#123;</span><br><span class="line">    int a;//成员a</span><br><span class="line">    int b;//成员b</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>枚举</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum em&#123;</span><br><span class="line">    red=0,</span><br><span class="line">    green,</span><br><span class="line">    black</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>文件操作</p><ol><li>文件类型 FILE* file</li><li>打开文件 FILE* fopen(path,mode)</li><li>fwrite/fread</li><li>fclose</li><li>文件游标操作 rewind</li></ol></li><li><p>指针</p><ol><li>它就是变量在内存中的一个地址；</li><li>指针本身的运算；</li><li>指针所指的内容的运算；</li></ol></li></ol><ol><li><p>操作系统如何管理内存；</p><ol><li>内核空间</li><li>栈控件；</li><li>引用库</li><li>堆空间</li><li>内存映射</li><li><p>内存的分配与释放；</p><ol><li>分配： void* mem = malloc(size);</li><li>释放：free(mem);</li></ol></li><li><p>内存泄漏与野指针</p><ol><li>不断的向系统申请内存；</li><li>申请内存不用，也不释放；</li><li>占用别人的内存成为野指针；</li></ol></li></ol></li><li><p>函数指针</p><ol><li>返回值类型 (* 指针变量名)([形参列表])<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int func(int x)函数</span><br><span class="line">int （*f）(int x);</span><br><span class="line">f =func;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>编译器；</p><ol><li>gcc：linux下的编译器</li><li>clang：mac下使用的编译器</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gcc/clang -g -O2 -o test test.c -I</span><br><span class="line">注释：</span><br><span class="line">1. -g:输出文件中的调试信息；</span><br><span class="line">2. -O：对输出文件做指令优化；</span><br><span class="line">3. -o：输出文件</span><br><span class="line">4. -I：指定头文件；</span><br><span class="line">5. -L：指定三方库文件位置；</span><br><span class="line">6. -l:指定使用哪个库</span><br></pre></td></tr></table></figure></li><li><p>编译过程：</p><ol><li>预编译：#\&lt;include>，将引用到文件，头文件加载</li><li>编译</li><li>链接：将系统库和三方库 与编译好的项目代码进行合并<ol><li>动态链接：代码执行中进行链接</li><li>静态链接: </li></ol></li></ol></li></ol></li><li><p>调试器</p><ol><li>gdb：</li><li>lldb：</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h1 id=&quot;3。数据类型&quot;&gt;&lt;a href=&quot;#3。数据类型&quot; class=&quot;headerlink&quot; title=&quot;3。数据类型&quot;&gt;&lt;/a&gt;3
      
    
    </summary>
    
      <category term="java" scheme="http://wenchaos.com/categories/java/"/>
    
    
      <category term="并发" scheme="http://wenchaos.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频入门基础</title>
    <link href="http://wenchaos.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/"/>
    <id>http://wenchaos.com/音视频基础/音视频入门基础/</id>
    <published>2018-04-08T16:00:00.000Z</published>
    <updated>2019-06-12T13:57:54.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><h2 id="1-1音视频知识"><a href="#1-1音视频知识" class="headerlink" title="1.1音视频知识"></a>1.1音视频知识</h2><ol><li>音视频采集</li><li>音视频硬软编解码</li><li>FFmpeg</li><li>WebRTC</li><li>音视频处理架构</li><li>网络传输</li></ol><h1 id="2-音频入门基础"><a href="#2-音频入门基础" class="headerlink" title="2.音频入门基础"></a>2.音频入门基础</h1><h1 id="3-视频入门基础"><a href="#3-视频入门基础" class="headerlink" title="3.视频入门基础"></a>3.视频入门基础</h1><ol><li>视频基本知识</li><li>H264宏块的划分与帧分组</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h1&gt;&lt;h2 id=&quot;1-1音视频知识&quot;&gt;&lt;a href=&quot;#1-1音视频知识&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
      <category term="java" scheme="http://wenchaos.com/categories/java/"/>
    
    
      <category term="并发" scheme="http://wenchaos.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ffmepg中的文件操作</title>
    <link href="http://wenchaos.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/FFmpeg/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://wenchaos.com/音视频基础/FFmpeg/文件操作/</id>
    <published>2018-04-08T16:00:00.000Z</published>
    <updated>2019-07-13T10:12:31.862Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>文件创建和删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;libavformat/&gt;avformat.h&gt;</span><br><span class="line">#include &lt;libavutil/log.h&gt;</span><br><span class="line"></span><br><span class="line">//删除文件</span><br><span class="line">int ret = avpriv_io_delete(filepath);</span><br><span class="line">   </span><br><span class="line">// 重命名文件</span><br><span class="line">avpriv_io_move(sourcefilename,targetfilename);</span><br><span class="line"></span><br><span class="line">//操作目录</span><br><span class="line">avio_open_dir();</span><br><span class="line">//</span><br><span class="line">avio_read_dir();</span><br><span class="line">//</span><br><span class="line">avio_close_dir();</span><br><span class="line">//</span><br><span class="line">avio_free_directory_entry();</span><br></pre></td></tr></table></figure></li><li><p>重要结构体</p><ol><li>AVIODirContext:操作目录的上下文；</li><li>AVIODirEntry: 目录项。 用于存放文件名，文件大小信息</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;文件创建和删除&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
      <category term="ffmpeg" scheme="http://wenchaos.com/categories/ffmpeg/"/>
    
    
      <category term="ffmpeg" scheme="http://wenchaos.com/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>兄台，这本网络秘籍是你的吗</title>
    <link href="http://wenchaos.com/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%85%84%E5%8F%B0%EF%BC%8C%E8%BF%99%E6%9C%AC%E7%BD%91%E7%BB%9C%E7%A7%98%E7%B1%8D%E6%98%AF%E4%BD%A0%E7%9A%84%E5%90%97/"/>
    <id>http://wenchaos.com/网络基础/兄台，这本网络秘籍是你的吗/</id>
    <published>2018-04-04T16:00:00.000Z</published>
    <updated>2019-08-12T14:35:04.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为软件工程师，必须要掌握诸多计算机领域的相关基础。其中计算机网络就好比武林秘籍中的洗髓经，每日勤加练习，必定能够对上层修为更加纯熟。那么本文则主要阐述了一些计算机网络的重点部分。</p><h1 id="网络技术的基本原理"><a href="#网络技术的基本原理" class="headerlink" title="网络技术的基本原理"></a>网络技术的基本原理</h1><p>计算机网络的核心内容就是网络协议的学习。网络协议是计算机网络中进行数据交换以及数据传输的建立的标准。因为不同用户的数据终端可能采取的字符集不同，所以必须要在一致的标准协议下进行。</p><h2 id="网络层次划分"><a href="#网络层次划分" class="headerlink" title="网络层次划分"></a>网络层次划分</h2><h3 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h3><ol><li>应用层：为操作系统或网络应用程序提供访问网络服务的接口。</li><li>表示层：<ol><li>作用：表示层的数据转换包括数据的加密、压缩、格式转换等。以保证一个主机应用层信息可以被另一个主机的应用程序理解。</li></ol></li><li>会话层：<ol><li>作用：<ol><li>会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。</li><li>会话层还利用在数据中插入校验点来实现数据的同步。</li></ol></li></ol></li><li>传输层：第一个端到端，即主机到主机的层次。<ol><li>作用：<ol><li>传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。</li><li>传输层还要处理端到端的差错控制和流量控制问题</li></ol></li><li>在这一层，信息传送的协议数据单元称为段或报文。</li><li>主要协议：<ol><li>TCP协议：传输控制协议</li><li>UDP协议：用户数据包协议</li></ol></li><li>重要设备：网关</li></ol></li><li>网络层：实现两个端系统之间的数据透明传送，具体功能包括<strong>寻址</strong>和<strong>路由选择</strong>、<strong>连接的建立、保持和终止等</strong>。<ol><li>重要的协议：<ol><li>IP协议<ol><li>仅仅提供不可靠，无连接的传输协议。</li><li>主要功能：<ol><li>无连接输数据报传输；</li><li>数据报路由选择</li><li>差错控制</li></ol></li></ol></li><li>ARP：地址解析协议</li><li>RARP：反向地址解析协议</li><li>ICMP：Intel报文协议</li></ol></li><li>网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；</li><li>重要的设备：路由器</li></ol></li><li>数据链路层：在物理层提供的服务的基础上向网络层提供服务，其最基本的服务<strong>是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。</strong> 必须具备的功能是：如何将数据组合的数据块（数据帧frame），如何控制帧在物理信道上的传输，如何处理传输差错，如何调节发送接收速率，以及两个网络实体之间的数据链路通路的建立，维持和释放的管理。<ol><li>物理地址寻址</li><li>数据的成帧</li><li>流量控制</li><li>数据的检错</li><li>重发</li><li>主要协议：以太网协议</li><li>重要设备：网桥；交换机</li></ol></li><li>物理层：物理层确保原始的数据可在各种物理媒体上传输<ol><li>中继器</li><li>集线器</li></ol></li></ol><h3 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h3><ol><li>应用层</li><li>传输层</li><li>网络层</li><li>数据链路层</li></ol><p>由于早期ARPA公司率先在市场中推广了TCP/IP协议，使得后来ISO组织制定的OSI七层网络模型难以普及。这么看来率先抢占市场对于一个事物的发展是多么的重要！</p><h3 id="七层与四层之间的关系"><a href="#七层与四层之间的关系" class="headerlink" title="七层与四层之间的关系"></a>七层与四层之间的关系</h3><p>如图所示：</p><p><img src="/Users/chaos/Library/Application Support/typora-user-images/image-20190812223450184.png" alt="image-20190812223450184"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;作为软件工程师，必须要掌握诸多计算机领域的相关基础。其中计算机网络就好比武林秘籍中的洗髓经，每日勤加练习，必定能够对上层修为更加纯熟。那么本
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://wenchaos.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Android开发需要知道gradle的常用知识</title>
    <link href="http://wenchaos.com/android%E5%BC%80%E5%8F%91/Android%E5%BC%80%E5%8F%91%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93gradle%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86/"/>
    <id>http://wenchaos.com/android开发/Android开发需要知道gradle的常用知识/</id>
    <published>2018-03-27T16:00:00.000Z</published>
    <updated>2018-04-21T08:04:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>#</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#&lt;/p&gt;

      
    
    </summary>
    
      <category term="工具类" scheme="http://wenchaos.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
      <category term="gradle" scheme="http://wenchaos.com/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Java的常用知识整理</title>
    <link href="http://wenchaos.com/java%E5%9F%BA%E7%A1%80%E7%AF%87/java%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>http://wenchaos.com/java基础篇/java的常用知识整理/</id>
    <published>2018-03-27T16:00:00.000Z</published>
    <updated>2019-07-30T23:38:00.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java主要方面"><a href="#Java主要方面" class="headerlink" title="Java主要方面"></a>Java主要方面</h1><ol><li>面向对象的特性</li><li>集合（特点，数据结构（数组，栈，队列，双向队列，红黑树，二叉树等））</li><li>JVM虚拟机（加载机制/内存以及垃圾回收）</li><li>线程与进程，异步</li><li>注解/反射/泛型</li><li>设计模式（单例，建造者，适配器，工厂，策略，观察者，代理）</li><li>算法（数据结构/排序，查找等）</li></ol><h1 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h1><ol><li>抽象：针对某一类对象的共同特征总结出来构造类的过程，抽象只关注对象有哪些共同的属性和行为，而不关心具体内容<ol><li>数据抽象</li><li>行为抽象</li></ol></li><li>继承：从已有类得到继承信息创建新类的过程。</li><li>封装：通常认为封装是把数据和行为绑定起来，对数据的访问只能通过定义的接口。封装就是隐藏一切可以隐藏的东西，只向外界提供最简单的编程接口。</li><li><p>多态性：指的是允许不同子类型的对象对同一消息作出不同的行为。即同样的对象引用调用同样的方法，但是做了不同的事情。</p><ol><li>编译时多态：方法重载（前期绑定），同一个类中，同名方法不同参；对返回值没有要求</li><li>运行时多态：方法重写（后期绑定），<ol><li>父子类中，即 子类继承父类已有的或者抽象的方法；</li><li>返回类型相同，</li><li>修饰符权限更开放，</li><li>不能比父类声明更多的异常（里氏替换原则）</li><li>方法重写，2. 对象造型（向下）即：用父类型引用 引用子类型对象实例，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为</li></ol></li><li><p>多态性的作用：</p><ol><li>封装：可以隐藏实现细节，便于模块化；继承可以扩展已存在的类；封装和继承都是为了代码重用性，而多态则是为了实现—接口重用！真正具有价值的重用就是“接口重用”，因为接口设计比实现接口更费时间，更花费工程师的精力。</li></ol><h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5></li><li><p>问题：从JVM/深一层的角度具体描述一下实现的机制？？？</p></li><li>继承与组合的不同</li></ol></li></ol><h3 id="访问修饰符的区别"><a href="#访问修饰符的区别" class="headerlink" title="访问修饰符的区别"></a>访问修饰符的区别</h3><ol><li>public：对所有类公开，不论是不是同一包下</li><li>protect ：仅仅对同包下子类公开</li><li>default：默认对于同一个包下的其他类相当于public，非同一个包下的相当于private</li><li>private：仅仅当前类中可以访问到</li></ol><h5 id="java面试题180"><a href="#java面试题180" class="headerlink" title="java面试题180"></a>java面试题180</h5><ol><li>（上） <a href="http://blog.csdn.net/jackfrued/article/details/44921941" target="_blank" rel="noopener">http://blog.csdn.net/jackfrued/article/details/44921941</a>  例：</li><li><p>String是基本类型吗？答：不是，基本类型有八种：byte ,short , int , long , double , float , char , boolean; 其他的都是引用类型，Java5引入的枚举enum也属于引用类型</p></li><li><p>解释内存中的栈（stack）堆（heap）和方法区（method area）</p><ol><li>栈空间：通常基本数据类型，对象的引用，以及函数调用的现场保存 </li><li>堆空间：通过new或者构造器创建的对象 （垃圾回收的主要区域，因为垃圾回收器大多数采用分代收集算法，所以堆空间还细分了 新生代，老生代）</li><li>方法区：方法区和堆空间都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息，常量，静态变量，JIT编译器编译后的代码等数据；</li><li>程序中的字面量，如100，“Hello”和常量都是放在常量池中，常量池是方法区的一部分</li><li>栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数进行调整</li><li>栈空间用光了会引发StackOverflowError，而堆空间和常量池不足则会引发OutOfMemoryError</li><li>例子：String str = new String（“Hello”）中，变量str，作为引用，放在栈中；new创建的字符串对象放在堆上，而“Hello”这个字面量放在方法区</li><li>补充：<ol><li>Java6 开始，由于JIT编译器的发展和“逃逸技术”逐渐成熟，栈上分配，标量替换等优化技术使得对象不一定非得分配在堆中；</li><li>运行时常量池相当于Class文件常量池具有动态性，Java语言并不要求常量一定只有编译器才能产生，运行期也可以将新的常量放入池中，String的intern()方法就是这样；</li></ol></li></ol></li><li><p>switch能否作用在byte，long上？String呢；（为什么？？？）</p><ol><li>答：Java 5 以前只能是byte ，short，char，int ；java 5 开始引入enum；Java 7 开始引入String；而long不可以；</li></ol></li><li>两个对象值相同（x.equals(y) == true），但却可以有不同的hash code吗？<ol><li>答：不对；Java对于equals方法和hashcode方法是这样规定：</li><li>如果两个对象相同（x.equals(y) == true），那么他们的hashCode值一定要相同；</li><li>如果两个对象hashCode相同，他们不一定相同；</li><li>补充：如果违背了java的这种规则，就会发现：在使用容器时，相同的对象可以set集合中出现，同时增加新元素的效率大大下降（这是因为使用哈希存储的系统，如果哈希码频繁的冲突，将会造成存取性能的急剧下降）</li><li>补充：equals方法必须满足：自反性，对称性，传递性，一致性</li><li>补充：重写equals方法的优秀要求：<ol><li><ol><li>使用==操作符检查”参数是否为这个对象的引用”；</li></ol></li><li><ol><li>使用instanceof操作符检查”参数是否为正确的类型”；</li></ol></li><li><ol><li>对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；</li></ol></li><li><ol><li>编写完equals方法后，问自己它是否满足对称性、传递性、一致性；</li></ol></li><li><ol><li>重写equals时总是要重写hashCode；</li></ol></li><li><ol><li>不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。  </li></ol></li></ol></li></ol></li><li>String和StringBuilder StringBuffer的区别<ol><li>String：不可变，只读</li><li>StringBuilder：可修改，Java 5引入，单线程，因为没有被做线程安全的处理，所以效率比StringBuffer高</li><li>StringBuffer：可修改，多线程安全，效率相对低</li><li>补充：什么情况下用 +运算符进行字符串连接，比用StringBuffer和StringBuilder性能好；<ol><li>+运算符的操作本质是创建了StringBuilder对象进行append操作，然后将结果toString</li></ol></li></ol></li><li><p>描述一下JVM加载class文件的原理机制</p><ol><li>JVM中类的装载是由类加载器（classLoader）和他的子类来实现的；是java运行时系统的一个重要组件，负责在运行时查找和装入类文件</li><li>由于java的跨平台型，经过编译的java源程序并不是一个可执行程序，而是一个或多个中间文件。</li><li>当java程序需要某个文件时，JVM会确保这个类已经被加载–&gt;链接（验证—&gt; 准备—&gt;解析）—&gt;初始化。类的加载是指把类的.class文件读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。</li><li>加载完成后，Class对象还不完整，还不可用。被加载后，进入连接过程，包括验证，，准备（为静态变量分配内存，设置初始值）和解析（将符号引用替换成直接引用）。</li><li>最后JVM对类进行初始化。如果该类存在直接的父类并且这个父类也还没有被初始化，则先初始化父类；如果该类中存在初始化语句，就依次执行这些初始化语句</li><li>类加载器：<ol><li>根加载器：Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）（不是java语言所编写的）</li><li>扩展加载器：Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；</li><li>系统加载器：System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</li><li>用户自定义加载器：</li><li>加载流程：应用启动：JVM启动—&gt;bootstrap classloader运行，加载java运行的核心类库，同时加载扩展加载器和系统加载器；—&gt;扩展加载器去加载扩展Api，—&gt;app classloader 加载CLASSPATH 目录下定义的class，通常没有特别指定的情况下，程序自定义类文件有系统加载器加载。</li></ol></li><li>双亲委托模式：<ol><li>优先判断父类加载器是否已经加载class文件，如果没有则子类进行；若parent classloader为null ，则调用 bootstrap classloader进行加载</li><li>优缺点：<ol><li>避免重复加载</li><li>安全问题：如果不适用这个模式，则有可能造成外来类替换java核心类的安全隐患</li></ol></li><li>流程：<ol><li>入口在ClassLoader.loadClass(name,boolean resolve):类名称，是否需要解析类；在执行类之前，需要考虑是否需要解析类，并不总是需要解析，如果JVM只需要知道该类是否存在或找出该类的超类，则不需要解析</li><li>defineClass<ol><li>接受由原始字节组成的数组，并将之转成Class对象。原始数组包含从文件系统或者网络装入的数据。defineClass管理JVM的许多复杂实现，它把字节码分析成运行时数据结构，校验有效性等。该方法为finla，不可重写</li></ol></li><li>findSystemClass方法<ol><li>从本地文件系统装入</li></ol></li></ol></li></ol></li><li><p>Class.forName 与classloader加载的类文件有什么区别</p><ol><li>loadClass加载 类实际上是在加载的时候并不对该类进行解析，因此不会初始化该类；而Class.forName则想反，在forName加载的时候就会将Class进行解析以及初始化！</li></ol><h3 id="抽象类与接口的区别："><a href="#抽象类与接口的区别：" class="headerlink" title="抽象类与接口的区别："></a>抽象类与接口的区别：</h3></li><li><p>相同点：</p><ol><li>不能被实例化</li><li>可以定义抽象类和接口类型的引用</li></ol></li><li>不同点：<ol><li>抽象类：可以有构造器；可以有抽象方法，具体方法；不一定有抽象方法；可以有private、默认、protected、public的成员变量</li><li>接口：没有构造器；只能有抽象方法；只能是常量 public static final ；没有静态方法</li><li>在继承体系中，抽象类继承是属于is-a的关系；接口的实现属于has-a的关系</li></ol></li><li>语法层面上的区别<ol><li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的</li><li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ol></li><li><p>设计层面上的区别</p><ol><li>抽象层次不同：抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象</li><li>跨域不同，抽象类作为很多子类的父类，它是一种具有相似特点的类。而接口是一种行为规范，它可以跨多种域，它是一种辐射式设计</li><li>设计层次不同：对于抽象类，它是自子类而父类来设计（自下而上），先知道子类才能抽象出父类，而接口不同，接口只是定义一种行为，不管行为的具体实施。</li></ol><h1 id="集合部分"><a href="#集合部分" class="headerlink" title="集合部分"></a>集合部分</h1></li><li><p>Collection：Java不提供直接继承Collection</p><ol><li>List：有序，索引，可重复<ol><li>ArrayList：<ol><li>允许所有元素，包括null</li><li>不是线程安全</li></ol></li><li>LinkedList：<ol><li>允许null元素，</li><li>常常被用作stack，queue，deque（双向队列）</li><li>不是线程安全！一种解决方法是在创建List时构造一个同步的List：List list = Collections.synchronizedList(new LinkedList(…));</li></ol></li><li>Vector：线程安全！非常类似ArrayList<ol><li>Stack：实现一个后进先出的堆栈；push，pop，peak，empty，search</li></ol></li></ol></li><li>Set：无重复<ol><li>HashSet</li><li>TreeSet</li><li>LinkedHashSet</li></ol></li><li>Queue<ol><li>PriorityQueue</li></ol></li><li>Collection类型的集合都支持iterator()方法，该方法返回一个Iterator it = collection.iterator(); // 获得一个迭代子</li></ol></li><li>Map：内部一个K-V映射的哈希表，由于作为key的对象将通过计算其散列值来确定与之对应的value的位置，因此任何作为key的对象必须实现hashCode，equals方法<ol><li>HashMap：键值对允许null，</li><li>HashTable：键值对非null，同步的</li><li>WeakHashMap：</li><li>TreeMap与TreeSet：<ol><li>TreeMap继承Map，TreeSet继承Set，TreeSet底层是通过TreeMap来实现的（如同HashSet底层是通过HashMap还实现的）</li><li>TreeMap的实现就是红黑树算法</li><li>相同点：<ol><li>都是有序集合，存储的值都是排好序的；</li><li>都是非同步集合，不能在多线程环境中使用，（可以使用Collections.synchronizedMap()进行同步化）</li><li>运行速度都要比hash集合慢，内部对元素的操作 时间复杂度为O(logN)，而HashMap/HashSet则为O(1)。因为一个是树结构，一个数组结构</li></ol></li><li>不同点：<ol><li>主要区别是实现接口不一样；</li><li></li></ol></li></ol></li></ol></li><li><p>涉及到堆栈，队列：list</p><h1 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h1></li><li><p>Synchronized，volatile，</p></li><li>java.util.concurrent.locks.Lock</li><li>Semaphore信号量</li><li>FutureTask：<ol><li>类似Runnable，都可以通过Thread来启动；不同的是FutureTask可以返回执行完毕后的数据，并且get（）是阻塞的；</li><li>可用于进行资源的预处理/预加载</li></ol></li><li>CyclicBarrier：可以阻塞一组线程，当同时满足条件后，才能解除阻塞继续执行下面的操作；单个线程中调用await（）并不管用；</li><li>Executor：线程池</li><li><p>Timer：定时器（偏向于单个任务）</p><ol><li>缺陷<ol><li>对于多个任务，timer内部只有一个任务线程，所以某个任务执行时间过长，导致不能按照我们定时器预定的执行；可以用ScheduledThreadPool弥补</li><li>一旦TimerTask出现了异常，Timer会停止所有任务的运行</li></ol></li></ol><h1 id="序列化以及意义："><a href="#序列化以及意义：" class="headerlink" title="序列化以及意义："></a>序列化以及意义：</h1></li><li><p>用来处理对象流的一种机制，所谓对象流也就是将对象的内容进行流化，可以对流化后的对象进行读写操作，或者传输于网络之间。序列化是为了解决对象流读写操作过程中可能引发的数据乱序问题。</p></li><li><p>实现序列化需要实现Serializable接口，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆（可以参考第29题）。</p><h1 id="final，finally-，finalize的区别"><a href="#final，finally-，finalize的区别" class="headerlink" title="final，finally ，finalize的区别"></a>final，finally ，finalize的区别</h1></li><li><p>final 用于控制成员变量，方法，或者是一个类是否可以被覆写或继承等功能；</p><ol><li>成员：<ol><li>一旦初始化后，不可改变；基础类型变量：值不改变，引用类型变量：引用不可改变（其初始化的地方在 声明处或者构造器中）</li><li>对于方法参数中final，基础类型的参数没有什么实际意义；但是对于引用类型的参数，因为其传递的是对象的引用，这样你在方法中对对象变量的修改也会影响到调用语句中对象变量。当方法中不需要改变作为参数的这个对象变量时，声明为final，防止你无意中修改到它而影响到方法的调用处。</li></ol></li><li>方法：<ol><li>不能重写，但是子类可以继承</li><li>允许编译器将所有对此方法的调用转化成inline（行内）调用的机制，它会在调用方法时，直接将方法主体插入到调用处，而不是进行例行的方法调用。提高了程序效率，但是当方法主体很大的时候，反而使得插入地方迅速膨胀，反而影响了效率。</li></ol></li><li>类：<ol><li>不可被继承；其中的方法也是默认为final</li></ol></li></ol></li><li>finally：对捕获异常模型的补充，finally块始终会最后执行。finally块中的return语句会覆盖之前的return结果</li><li><p>finalize：根据Java语言规范，JVM保证调用finalize函数之前，这个对象是不可达的，而且JVM不保证一定会调用该方法</p><h1 id="传递与引用"><a href="#传递与引用" class="headerlink" title="传递与引用"></a>传递与引用</h1></li><li><p>首先可以确定的说：Java传递的是值的副本</p><ol><li>基本类型变量：传递的是变量值的副本；也就是说即使副本被改变，原始变量值不会变</li><li>对象类型变量：传递的是引用的副本；因为传递的是引用，则引用内容可能会改变；</li></ol><h1 id="算法复杂度的计算："><a href="#算法复杂度的计算：" class="headerlink" title="算法复杂度的计算："></a>算法复杂度的计算：</h1></li><li><p>时间复杂度</p></li><li><p>空间复杂福</p><h1 id="JVM详解"><a href="#JVM详解" class="headerlink" title="JVM详解"></a>JVM详解</h1><h3 id="Java引用的四种状态"><a href="#Java引用的四种状态" class="headerlink" title="Java引用的四种状态"></a>Java引用的四种状态</h3></li><li><p>强引用：new出来的对象，处于堆内存中，指向它的引用在栈中（内存空间不足，也不回收）</p></li><li>软引用：（内存空间足，不回收；不足，可能会随时被回收）常用来实现内存敏感的高速缓存</li><li>弱引用：每次Gc时，一旦发现有弱引用对象，不管内存是否足，都会回收</li><li><p>虚引用：类似于没有任何引用一样，在任何时候都可能会被回收；主要用于跟踪对象呗垃圾回收器回收的活动</p><h3 id="Java中内存的划分"><a href="#Java中内存的划分" class="headerlink" title="Java中内存的划分"></a>Java中内存的划分</h3></li><li><p>程序计数器：保证线程切换后能恢复到原来的执行位置 （线程私有）</p></li><li>jvm虚拟机栈：栈内存，为java方法服务，方法为调用 创建栈帧—&gt;局部变量表—&gt;局部变量，对象的引用，动态链接，方法出口灯（线程私有）（StackOverFlowError、OutOfMemoryError）</li><li>本地方法栈：为虚拟机运行使用到的Native方法服务（线程私有）（StackOverFlowError、OutOfMemoryError）</li><li>堆内存：存放所有new出来的对象（线程共享）（OutOfMemoryError）</li><li>方法区：存储被虚拟机JVM加载进来的类信息，常量，静态常量，静态方法等；（线程共享）</li><li>字符串常量池：方法区的一部分（线程共享）（OutOfMemoryError），一个由数组组成的表constant_pool[]用于存放Class，String以及基本类型的数据</li><li>补充：1，2，3这三个内存区域伴随线程，不需要考虑回收，线程结束，该区域自动会被回收；堆、方法区是Gc的主要战场，这里的内存分配是动态的</li><li><p>例子：String str = new String（“abc”）；创建了2个对象，一个在编译期创建“abc”，一个在运行期由new创建</p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3></li><li><p>对象在内存中的状态</p><ol><li>可到达：自创建后，被一个或多个变量引用，则可达；从根节点上可触及到这个对象（引用链）</li><li>可恢复：对象不再被任何变量引用就进入了可恢复状态，回收该对象之前，会先调用finalize()方法，如果有重新有变量引用，则可达；</li><li>不可达：　Java对象不被任何变量引用，且系统在调用对象的finalize()方法后依然没有使该对象变成可达状态（该对象依然没有被变量引用），那么该对象将变成不可达状态。当Java对象处于不可达状态时，系统才会真正回收该对象所占有的资源。</li></ol></li><li><p>判断对象死亡的两种常用算法</p><ol><li>引用计数法：给对象增加一个引用计数器，0&lt;，则有引用；0&gt;，则无变量引用<ol><li>优点：算法简单，判断效率高</li><li>缺点：很难解决对象之间相互循环引用的问题</li></ol></li><li>根搜索算法：（当前采用）<ol><li>设立若干种root对象，当任何一个root对象到某个对象不可达时，则认为该对象可以被回收</li><li>root对象：<ol><li>栈（栈帧中的本地变量表）中引用的对象</li><li>方法区的静态变量</li><li>方法区中的常量引用的变量</li><li>本地方法栈中的JNI（Native方法）引用的对象</li></ol></li></ol></li></ol></li><li><p>垃圾回收算法</p><ol><li>标记-清除：<ol><li>标记阶段：标记那些从根节点开始可到达的对象，未标记的则是待回收对象</li><li>清楚阶段：清除未标记的对象</li><li>优缺点：<ol><li>标记-清除效率不高，都需要从头遍历到尾，会产生大量的不连续内存碎片</li></ol></li></ol></li><li>复制：新生代gc<ol><li>将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，然后清除正在使用的内存块中的所有对象。</li><li>优点：<ol><li>不用考虑内存碎片，只需要移动堆顶指针，按顺序分配内存即可，简单效率高</li></ol></li><li>缺点：<ol><li>空间浪费</li></ol></li><li>补充：现在的商业虚拟机都采用这种收集算法来回收新生代，新生代中的对象98%都是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块比较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。</li><li>当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖于老年代进行分配担保，所以大对象直接进入老年代。</li></ol></li><li>标记-整理：老年代的gc<ol><li>标记阶段：标记从根节点开始的可达对象</li><li>整理阶段：将所有可达对象压缩到内存的一端，之后清理边界外的所有空间</li><li>优点：<ol><li>不产生内存碎片</li></ol></li><li>缺点：<ol><li>在标记的基础上，还需要进行对象的移动，成本相对较高，效率也不高</li></ol></li></ol></li><li>分代收集算法（当前采用）<ol><li></li></ol></li></ol></li><li><p>垃圾回收器</p><ol><li>Serial收集器：Client模式下的新生代收集器</li><li>Serial old收集器：client模式下的老年代收集器</li><li>ParallNew收集器：server模式下的首选新生代收集器</li><li>G1收集器：更加关注停顿时间</li><li>CMS收集器：并发标记清除，获取最短回收停顿时间为目标，老年代收集器</li></ol></li><li><p>堆内存划分</p><ol><li>新生代</li><li>老年代</li><li>永久代</li></ol></li><li><p>MinorGc ，FullGc</p><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><ol><li>过程：</li><li>类加载器</li><li>双亲委派模型</li></ol><h1 id="内存泄漏-缓存"><a href="#内存泄漏-缓存" class="headerlink" title="内存泄漏/缓存"></a>内存泄漏/缓存</h1><h1 id="数据结构与排序-查找："><a href="#数据结构与排序-查找：" class="headerlink" title="数据结构与排序/查找："></a>数据结构与排序/查找：</h1></li><li><ol><li>链表</li><li>栈</li><li>堆</li><li>数组</li><li>树：<ol><li>二叉树（前序，中序，后序），</li><li>平衡二叉树：</li><li>红黑树</li></ol></li><li>图：<ol><li>深度优先遍历：（有些类似二叉树的前序遍历）</li><li>广度优先遍历：（有些类似二叉树的按层次遍历）</li></ol></li><li>实现搜索引擎的搜索建议的后台技术所采用的数据结构：<ol><li>字典树，一种哈希树的变种，快速检索的多叉树。典型用于统计和排序大量的字符串等文本词频</li><li>减少无谓的字符串比较，</li><li>空间换取时间</li></ol></li></ol></li><li><p>排序：</p><ol><li>气泡排序</li><li>插入排序</li><li>二叉树排序</li><li>选择排序</li><li>堆排序</li><li>快速排序</li><li>交换排序</li><li>补充：<ol><li>记录规模较小时，n《50，可采用直接插入或直接选择排序；相反n》50，应该采用时间复杂度为O（nlogn）的排序：快速排序，堆排序</li></ol></li></ol><h1 id="反射与泛型："><a href="#反射与泛型：" class="headerlink" title="反射与泛型："></a>反射与泛型：</h1></li><li><p>泛型：泛型的本质就是参数化类型；这种参数类型可用在接口，类，方法的创建中，分别称为泛型接口，泛型类，泛型方法</p><h1 id="枚举：Java1-5开始支持，java-lang-Enum为抽象类"><a href="#枚举：Java1-5开始支持，java-lang-Enum为抽象类" class="headerlink" title="枚举：Java1.5开始支持，java.lang.Enum为抽象类"></a>枚举：Java1.5开始支持，java.lang.Enum为抽象类</h1></li><li><p>对Set和Map也提供支持：EnumSet EnumMap</p></li><li>枚举类中：常量，属性，构造方法，普通方法，抽象方法等</li><li>通过编译，生成抽象类并继承Enum，常量—&gt;final，静态$VALUES[]保存所定义的所有枚举常量；每一个定义的常量都会生成一个final内部类，里面的属性和大部分方法都是final的，通过静态代码块进行初始化，保证了枚举不可变性，不能clone，Serilizable等。</li><li><p>由3的产生中间类代码，可以知道：Enum相对于静态字符串常量占用的内存是比较大的</p><h1 id="动态代理："><a href="#动态代理：" class="headerlink" title="动态代理："></a>动态代理：</h1></li><li></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java主要方面&quot;&gt;&lt;a href=&quot;#Java主要方面&quot; class=&quot;headerlink&quot; title=&quot;Java主要方面&quot;&gt;&lt;/a&gt;Java主要方面&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;面向对象的特性&lt;/li&gt;
&lt;li&gt;集合（特点，数据结构（数组，栈，队列，双向队列
      
    
    </summary>
    
    
      <category term="java" scheme="http://wenchaos.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>git的常用场景</title>
    <link href="http://wenchaos.com/%E5%B7%A5%E5%85%B7%E7%AF%87/git%E7%9A%84%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://wenchaos.com/工具篇/git的常用场景/</id>
    <published>2018-03-24T16:00:00.000Z</published>
    <updated>2018-04-21T07:38:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git的常用命令"><a href="#git的常用命令" class="headerlink" title="git的常用命令"></a>git的常用命令</h1><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li><p>本地仓库与git remote仓库的关联</p><ul><li>首先要在github账户上，创建与本地仓库同名的仓库repository;</li><li>进入本地仓库的根目录，开始下面一系列的操作<ol><li>可以选择创建readme.md文件；　echo “# -“ &gt;&gt; README.md</li><li>初始化该仓库；　git init</li><li>将创建的文件README.md文件放置暂存区；　git add README.md</li><li>将暂存区的修改提交; git commit -m “你的提交信息”</li><li>将本地仓库推送到github上；git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:账户名/仓库名.git,git push -u origin master</li></ol></li><li>到此已经基本完成。但是还是需要将你的电脑配置一下<ol><li>git config –global user.name “your account name”</li><li>git config –global user.email “your account email”</li><li>到此已经在当前用户配置了你的信息。下面需要生成你的ssh-key并添加到github上</li><li>生成秘钥；ssh-keygen -t rsa -C “your account email” (连续回车三次)</li><li>最后将公钥添加到git账户里，就OK啦。</li></ol></li><li><p>有时候工作环境和个人环境都需要一个秘钥，这时候可以在生成秘钥的时候，指定名字并且需要添加config文件进行指定</p><ol><li>生成指定名称的秘钥；ssh-keygen -t rsa -C “your account email” -f ~/.ssh/指定文件名</li><li><p>添加特别的配置，在ssh目录下新建config文件，内容如下</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host github-aysee</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile <span class="symbol">C:</span>/Users/username/.ssh/aysee</span><br><span class="line">你应该可以看懂的吧－－</span><br></pre></td></tr></table></figure><ol><li>在指定项目下，指定作者<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;Author name&quot;</span><br><span class="line">git config user.email &quot;Author email&quot;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ul></li><li><p>一次git提交生命过程中遇到的兄弟们（这里并不准备详细的介绍这些哥们）</p><ul><li>新建文件/目录，修改，提交</li><li><p>一般仓库中的文件可能存在于这三种状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Untracked files 文件未被跟踪　【处于工作区】</span><br><span class="line">2. Changes to be committed 文件已经被暂存，这是下次提交的内容　【处于暂存区】</span><br><span class="line">3. Changes but not updated 文件被修改，但没有添加到暂存区　【工作区】</span><br></pre></td></tr></table></figure></li><li><p>在开始新的路上，要把有变化的文件添加到索引库中，这个时候首先要遇见：git add命令</p><ol><li>git add -A [path]: 表示把path内的所有的tracked文件那些被修改／被删除／以及untrack的文件，添加到索引库中</li><li>git add -u [path]: 把path中所有的tracked文件，那些被修改／被删除的文件，添加到索引库中</li><li>git add -i [path]: 可以查看到path中所有被修改过／被删除但是还没有提交的文件</li><li>add兄弟家族还有好多，具体可以看看–help管家</li></ol></li><li><p>经历了add家族的接待，那些被添加到索引库的文件即将遇到另外一个兄弟：git commit命令，</p><ol><li>git commit -m “提交的描述信息”　：提交暂存区的文件</li><li>git commit -a -m “提交的描述信息”　：　提交暂存区以及工作区中已被tracked文件</li><li>git commit –amend “再次补充添加上次提交的描述信息”：补充提交信息</li></ol></li><li>经由commit的指引，我们来到了暂存区，这里都是即将要被push到老家的兄弟们：git push命令<ol><li>该命令用于将本地分支更新到暂存区的文件，推送到远程主机：</li><li>git push \&lt;远程主机&gt;　\&lt;本地分支&gt;:\&lt;远程分支名&gt; ; 一般常用 git push，其他更具体的用法请Ｇｏｏｇｌｅ</li><li>常见的一些情况：<ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.git push origin master :表示　将本地分支master推送到origin主机的master分支，如果不存在，则新建</span><br><span class="line">2.git push origin :master 表示　删除指定的远程分支master　</span><br><span class="line">    等同于推送一个空本地分支到远程分支</span><br><span class="line">    git push origin --delete master</span><br><span class="line">3.git push 推送当前分支到远程</span><br><span class="line">4.git push --all　推送所有本地分支到远程</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ul></li></ol><ol><li><p>天下大事，合久必分，分久必合。</p><ul><li><p>接下来git branch主要用法</p><ol><li>git branch 查看本地分支列表，当前分支“*”标示</li><li>git branch \<branchname>　创建分支，基于当前HEAD指向的提交</branchname></li><li>git branch \<branchname> \<start-point>　创建分支，基于指定的提交节点</start-point></branchname></li><li>git branch -d \<branchname> 　删除分支，弱删除（删除时检查索要删除的分支是否已经合并到其他分支中，否则拒绝）</branchname></li><li>git branch -D \<branchname>　强制删除</branchname></li><li>git branch -m \<oldbranch>　\<newbranch> 重命名分支，如果版本库中已经存在newbranch的分支，拒绝</newbranch></oldbranch></li><li>git branch -M \<oldbranch>　\<newbranch>　重命名分支，即使版本库中已经存在newbranch的分支，强制执行</newbranch></oldbranch></li></ol></li><li><p>那么git merge主要用法：把一个分支或某个commit的修改合并到现在的分支上</p><ol><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">usage: git merge [options] [&lt;commit&gt;...]</span><br><span class="line">   or: git merge [options] &lt;msg&gt; HEAD &lt;commit&gt;</span><br><span class="line">   or: git merge --abort</span><br></pre></td></tr></table></figure></li><li><p>先切换到目的分支：git checkout destination-branch</p></li><li>再将目标分支合并到目的分支：　git merge aim-branch</li><li>如果有冲突，先解决，再经过一次提交过程，完成合并</li></ol></li></ul></li></ol><ol><li>关于git的一些必要概念<ul><li>工作区：当前工程目录范围下</li><li>暂存区：即stage，一般存放在工程根目录下的.git/index文件夹，</li><li>版本库：工作区有一个隐藏目录.git　这个就是当前工程的版本库,是一个简单的数据库，其中包含所有用来维护与管理项目修订版本与历史信息。</li></ul></li></ol><p>##Git中rebase与merge的区别<br>    1. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git的常用命令&quot;&gt;&lt;a href=&quot;#git的常用命令&quot; class=&quot;headerlink&quot; title=&quot;git的常用命令&quot;&gt;&lt;/a&gt;git的常用命令&lt;/h1&gt;&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="工具类" scheme="http://wenchaos.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
      <category term="git" scheme="http://wenchaos.com/tags/git/"/>
    
  </entry>
  
</feed>
