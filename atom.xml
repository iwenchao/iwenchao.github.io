<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大王派我来巡山</title>
  
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wenchaos.com/"/>
  <updated>2019-07-28T08:47:09.735Z</updated>
  <id>http://wenchaos.com/</id>
  
  <author>
    <name>wenchaos</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mergeExtDexDebug出现的问题</title>
    <link href="http://wenchaos.com/%E9%97%AE%E9%A2%98%E5%86%8C/mergeExtDexdebugFail/"/>
    <id>http://wenchaos.com/问题册/mergeExtDexdebugFail/</id>
    <published>2019-04-06T16:00:00.000Z</published>
    <updated>2019-07-28T08:47:09.735Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="android" scheme="http://wenchaos.com/categories/android/"/>
    
    
      <category term="问题册" scheme="http://wenchaos.com/tags/%E9%97%AE%E9%A2%98%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>android中侧边栏的使用剖析</title>
    <link href="http://wenchaos.com/android%E5%BC%80%E5%8F%91/android%E4%B8%AD%E4%BE%A7%E8%BE%B9%E6%A0%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%89%96%E6%9E%90/"/>
    <id>http://wenchaos.com/android开发/android中侧边栏的使用剖析/</id>
    <published>2019-03-04T16:00:00.000Z</published>
    <updated>2019-07-27T02:21:40.035Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="笔记" scheme="http://wenchaos.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="android" scheme="http://wenchaos.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android-support库迁移到androidx</title>
    <link href="http://wenchaos.com/%E9%97%AE%E9%A2%98%E5%86%8C/android-support%E7%89%88%E6%9C%AC%E8%BF%81%E7%A7%BB%E5%88%B0androidx/"/>
    <id>http://wenchaos.com/问题册/android-support版本迁移到androidx/</id>
    <published>2019-03-04T16:00:00.000Z</published>
    <updated>2019-07-28T08:53:28.797Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="android" scheme="http://wenchaos.com/categories/android/"/>
    
    
      <category term="问题册" scheme="http://wenchaos.com/tags/%E9%97%AE%E9%A2%98%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>multiDex的由来</title>
    <link href="http://wenchaos.com/android%E5%BC%80%E5%8F%91/multiDex%E7%9A%84%E7%94%B1%E6%9D%A5/"/>
    <id>http://wenchaos.com/android开发/multiDex的由来/</id>
    <published>2019-01-01T16:00:00.000Z</published>
    <updated>2019-07-28T14:05:52.590Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android接入ffmpeg的介绍</title>
    <link href="http://wenchaos.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/android%E6%8E%A5%E5%85%A5ffmpeg%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <id>http://wenchaos.com/音视频基础/android接入ffmpeg的介绍/</id>
    <published>2018-10-08T16:00:00.000Z</published>
    <updated>2019-07-28T07:54:07.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h3><ol><li>JNI</li><li>CPU架构</li><li>交叉编译</li><li>NDK</li><li>ffmpeg相关</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h3 id=&quot;必备知识&quot;&gt;&lt;a href=&quot;#必备知识&quot; class=&quot;headerlink&quot; title=&quot;必备知识&quot;&gt;&lt;/a&gt;必备知识&lt;/h
      
    
    </summary>
    
      <category term="android，ffmpeg" scheme="http://wenchaos.com/categories/android%EF%BC%8Cffmpeg/"/>
    
    
      <category term="音视频" scheme="http://wenchaos.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>ffmepg中的日志操作</title>
    <link href="http://wenchaos.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/FFmpeg/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    <id>http://wenchaos.com/音视频基础/FFmpeg/日志系统/</id>
    <published>2018-08-16T16:00:00.000Z</published>
    <updated>2019-07-28T07:53:33.192Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="ffmpeg" scheme="http://wenchaos.com/categories/ffmpeg/"/>
    
    
      <category term="ffmpeg" scheme="http://wenchaos.com/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>java的并发基础剖析</title>
    <link href="http://wenchaos.com/java%E5%B9%B6%E5%8F%91/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%E5%89%96%E6%9E%90/"/>
    <id>http://wenchaos.com/java并发/java并发基础部分剖析/</id>
    <published>2018-07-20T16:00:00.000Z</published>
    <updated>2019-07-29T00:14:06.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为常用java语言开发的从业人员，怎么能不了解java的并发呢？那么我们一点一点开始讲起。</p><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p>首先从进程与线程讲起，那么两者的异同点如下</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。（进程是资源分配的最小单位）</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）</p><h3 id="进程与线程的生命周期"><a href="#进程与线程的生命周期" class="headerlink" title="进程与线程的生命周期"></a>进程与线程的生命周期</h3><p>线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。</p><ul><li>创建：新创建了一个线程对象。</li><li>就绪：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。</li><li>运行：就绪状态的线程获取了CPU，执行程序代码。</li><li>阻塞<ul><li>等待阻塞：运行的线程执行wait(),JVM会把该线程放入等待池中（wait()会释放掉持有的锁）</li><li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</li><li>其他阻塞： 运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）</li></ul></li><li>终止：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li></ul><h3 id="线程优先级："><a href="#线程优先级：" class="headerlink" title="线程优先级："></a>线程优先级：</h3><ol><li>Java线程有优先级，优先级高的线程会获得较多的运行机会</li><li>优先级用整数表示，取值范围是1~10；<ol><li>MAX_PRIORITY：10 </li><li>NORM_PRIORITY：5</li><li>MIN_PRIORITY：1</li></ol></li></ol><h1 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h1><p>有一些关键方法，理解这些关键方法对理解线程有很大的帮助。</p><ol><li>线程sleep：Thread类方法；使线程转到阻塞状态；睡眠结束后，就转为就绪（Runnable）状态。<strong><em>\</em>不会释放持有的锁，只是让出了cpu时间**</strong></li><li>线程wait：Object类方法；导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法<strong><em>\</em>立即释放**</strong>对象监视器，notify()/notifyAll()方法则会<strong><em>\</em>等待线程剩余代码执行完毕**</strong>才会放弃对象监视器。</li><li>线程yield：Thread类方法。<strong><em>\</em>暂停**</strong>当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。</li><li>线程join：Thread.join()方法，当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个线程运行结束，当前线程再由阻塞转为就绪状态。</li><li>线程唤醒notify，notifyAll：Object类中的notify()方法，<strong>唤醒在此对象监视器上等待的单个线程</strong>。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。</li></ol><h1 id="java中如何实现多线程"><a href="#java中如何实现多线程" class="headerlink" title="java中如何实现多线程"></a>java中如何实现多线程</h1><h3 id="三种方式，并与Future、线程池结合使用"><a href="#三种方式，并与Future、线程池结合使用" class="headerlink" title="三种方式，并与Future、线程池结合使用"></a>三种方式，并与Future、线程池结合使用</h3><ol><li><p>Thread父类</p></li><li><p>Runnable接口</p></li><li><p>Callable接口 （java 5新增） 有返回值</p></li></ol><h3 id="实现Runnable接口相比继承Thread类有如下优势："><a href="#实现Runnable接口相比继承Thread类有如下优势：" class="headerlink" title="实现Runnable接口相比继承Thread类有如下优势："></a>实现Runnable接口相比继承Thread类有如下优势：</h3><ol><li><p>避免单继承带来的局限</p></li><li><p>增强代码的健壮性，代码能够被多个程序共享，代码与数据时独立的</p></li><li><p>合适多个相同程序代码的线程区处理同一资料的情况</p></li></ol><h1 id="线程安全与共享资源"><a href="#线程安全与共享资源" class="headerlink" title="线程安全与共享资源"></a>线程安全与共享资源</h1><p>允许被多个线程同时执行的代码称作线程安全的代码。线程安全的代码<strong><em>\</em>不包含竞态条件**</strong>。当多个线程同时更新共享资源时会引发竞态条件。<strong>因此，了解Java线程执行时共享了什么资源很重要</strong>。</p><ol><li><p>局部变量：</p><ol><li>局部变量存储在线程自己的栈中。也就是说，局部变量永远也不会被多个线程共享</li><li>基础类型的局部变量是线程安全的</li><li>引用类型的局部变量：如果在某个方法中创建的对象不会逃逸出该方法，即该对象既不会被其他方法获得，也不会被非局部变量引用，那么认为它是线程安全的。</li></ol></li><li><p>成员对象</p><ol><li>对象成员存储在堆上</li><li>如果两个线程同时更新同一个对象实例的同一个成员，那这个代码就不是线程安全的。</li></ol></li><li><p>线程控制逃逸规则：判断某些资源的访问是否线程安全</p><ol><li>如果一个资源的创建，使用，销毁都在同一个线程内完成，且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。</li></ol></li></ol><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h5 id="可中断锁Lock"><a href="#可中断锁Lock" class="headerlink" title="可中断锁Lock"></a>可中断锁Lock</h5><ol><li><p>ReenterantLock：可重入锁，</p></li><li><p>ReadWriteLock:一个用来获取读锁，一个用来获取写锁。也就是说，将对临界资源的读写操作分成两个锁来分配给线程，从而使得多个线程可以同时进行读操作。</p></li><li><p>ReentrantReadWriteLock：可重入锁，</p></li></ol><h5 id="不可中断锁synchronized"><a href="#不可中断锁synchronized" class="headerlink" title="不可中断锁synchronized"></a>不可中断锁synchronized</h5><ol><li>synchronized：不可中断锁<ol><li>Java中的同步块用synchronized标记。同步块在Java中是同步在某个对象上。所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。</li><li>实例方法：同步在拥有该方法的实例对象上。</li><li>静态方法：同步在该方法所在的类对象上。</li><li>实例方法中的同步块：在同步构造器中用括号括起来的对象叫做<strong><em>\</em>监视器对象**</strong>。使用监视器对象同步，同步实例方法使用调用方法本身的实例this作为监视器对象。一次只有一个线程能够在同步于同一个监视器对象的Java方法内执行。如果一个在this，另一个不在this，那么两个方法可以被线程同时执行。</li><li>静态方法中的同步块：同步在该方法所属的Class类对象上。等同于静态方法添加synchronized修饰，不可以同时被两个线程访问</li></ol></li></ol><h5 id="lock与synchronized的异同点"><a href="#lock与synchronized的异同点" class="headerlink" title="lock与synchronized的异同点"></a>lock与synchronized的异同点</h5><ol><li>Lock是一个接口，是JDK层面的实现；而synchronized是Java中的关键字，是Java的内置特性，是JVM层面的实现；</li><li>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li><li>Lock 可以让等待锁的线程响应中断，而使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li><li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到；</li></ol><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>待补充！</p><h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><p>目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号。</p><h3 id="方式有哪些？"><a href="#方式有哪些？" class="headerlink" title="方式有哪些？"></a>方式有哪些？</h3><ol><li><p>共享对象： 即<strong>java的内存模型 JMM</strong></p></li><li><p>忙等待</p></li><li><p>wait()； notify()； notifyAll()；</p><ol><li>Java有一个内建的等待机制来允许线程在等待信号的时候变为非运行状态。java.lang.Object 类定义了三个方法，wait()、notify()和notifyAll()来实现这个等待机制。</li><li>一个线程一旦调用了任意对象的wait()方法，就会变为非运行状态，直到另一个线程调用了同一个对象的notify()方法。为了调用wait()或者notify()，线程必须先获得那个对象的锁。也就是说，<strong><em>\</em>线程必须在同步块里调用wait()或者notify()**</strong></li><li>当一个线程调用一个对象的notify()方法，正在等待该对象的所有线程中将有一个线程被唤醒并允许执行（校注：这个将被唤醒的线程是随机的，不可以指定唤醒哪个线程）。同时也提供了一个notifyAll()方法来唤醒正在等待一个给定对象的所有线程。</li><li>如你所见，不管是等待线程还是唤醒线程都在同步块里调用wait()和notify()。这是强制性的！一个线程如果没有持有对象锁，将不能调用wait()，notify()或者notifyAll()。否则，会抛出IllegalMonitorStateException异常。</li><li>一旦线程调用了wait()方法，它就释放了所持有的监视器对象上的锁。这将允许其他线程也可以调用wait()或者notify()。</li><li>一旦一个线程被唤醒，不能立刻就退出wait()的方法调用，直到调用notify()的线程退出了它自己的同步块。换句话说：被唤醒的线程必须重新获得监视器对象的锁，才可以退出wait()的方法调用，因为wait方法调用运行在同步块里面。如果多个线程被notifyAll()唤醒，那么在同一时刻将只有一个线程可以退出wait()方法，因为每个线程在退出wait()前必须获得监视器对象的锁。</li></ol></li></ol><h6 id="问题：为何这三个不是Thread类声明中的方法，而是Object类中声明的方法？"><a href="#问题：为何这三个不是Thread类声明中的方法，而是Object类中声明的方法？" class="headerlink" title="问题：为何这三个不是Thread类声明中的方法，而是Object类中声明的方法？"></a>问题：为何这三个不是Thread类声明中的方法，而是Object类中声明的方法？</h6><p>​        其实这个问题很简单，由于每个对象都拥有monitor（即锁），所以让当前线程等待某个对象的锁，当然应该通过这个对象来操作了。而不是用当前线程来操作，因为当前线程可能会等待多个线程的锁，如果通过线程来操作，就非常复杂了。</p><ol><li><p>丢失的信号</p><ol><li>针对notify()有一个问题：即通知信号的丢失，如果一个线程先于被通知线程调用wait()前调用了notify()，等待的线程将错过这个信号。这可能使等待线程永远在等待。</li><li>为了避免信号丢失， 用一个变量来保存是否被通知过。在notify前，设置自己已经被通知过。在wait后，设置自己没有被通知过，需要等待通知。</li></ol></li><li><p>假唤醒</p><ol><li>由于莫名其妙的原因，线程有可能在没有调用过notify()和notifyAll()的情况下醒来。这就是所谓的假唤醒（spurious wakeups）。无端端地醒过来了。然后也能够执行后续的操作。这可能导致你的应用程序出现严重问题。</li><li><p>为了防止假唤醒，保存信号的成员变量将在一个while循环里接受检查，而不是在if表达式里。这样的一个while循环叫做自旋锁（校注：这种做法要慎重，目前的JVM实现自旋会消耗CPU，如果长时间不调用doNotify方法，doWait方法会一直自旋，CPU会消耗太大）。被唤醒的线程会自旋直到自旋锁(while循环)里的条件变为false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">MonitorObject myMonitorObject = <span class="keyword">new</span> MonitorObject();</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">boolean</span> wasSignalled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">​        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWait</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">while</span>(!wasSignalled)&#123;</span><br><span class="line"></span><br><span class="line">​                <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">​                myMonitorObject.wait();</span><br><span class="line"></span><br><span class="line">​                &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;...&#125;</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​            <span class="comment">//clear signal and continue running.</span></span><br><span class="line"></span><br><span class="line">​            wasSignalled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line"></span><br><span class="line">​            wasSignalled = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">​            myMonitorObject.notify();</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>​    - 留意wait()方法是在while循环里，而不在if表达式里。如果等待线程没有收到信号就唤醒，wasSignalled变量将变为false,while循环会再执行一次，促使醒来的线程回到等待状态。</p><p>\5. 多线程等待相同的信号</p><p>​    - 如果你有多个线程在等待，被notifyAll()唤醒，但只有一个被允许继续执行，使用while循环也是个好方法。每次只有一个线程可以获得监视器对象锁，意味着只有一个线程可以退出wait()调用并清除wasSignalled标志（设为false）。</p><p>​    - 一旦这个线程退出doWait()的同步块，其他线程退出wait()调用，并在while循环里检查wasSignalled变量值。但是，这个标志已经被第一个唤醒的线程清除了，所以其余醒来的线程将回到等待状态，直到下次信号到来。</p><p>\6. 不要对常量字符串或者全局对象调用wait()</p><p>​    - 在空字符串作为锁的同步块(或者其他常量字符串)里调用wait()和notify()产生的问题是，<strong><em>\</em>JVM/编译器内部会把常量字符串转换成同一个对象**</strong>。这意味着，即使你有2个不同的MyWaitNotify实例，它们都引用了相同的空字符串实例。同时也意味着存在这样的风险：在第一个MyWaitNotify实例上调用doWait()的线程会被在第二个MyWaitNotify实例上调用doNotify()的线程唤醒。</p><p>管程 (英语：Monitors，也称为监视器) 是<strong><em>\</em>对多个工作线程实现互斥访问共享资源的对象或模块**</strong>。这些共享资源一般是硬件设备或一群变量。管程实现了在一个时间点，最多只有一个线程在执行它的某个子程序。与那些通过修改数据结构实现互斥访问的并发程序设计相比，管程很大程度上简化了程序设计。</p><p><strong>###### 死锁</strong></p><p>\1. 死锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。</p><p>\2. 避免死锁</p><p>​    - 加锁顺序</p><p>​        - 当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。</p><p>​    - 加锁时限</p><p>​        - 按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁(译者注：并对这些锁做适当的排序)，但总有些时候是无法预知的。此时就需要另一个种方法：加时</p><p>​        - 在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。</p><p>​        - 高并发下，这种方式效率不高</p><p>​    - 死锁检测</p><p>​        - 主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。</p><p>\3. java中的锁</p><p>​    - 简单的锁 </p><p>​        - Lock.java 不可重入，因为存在自旋锁的原因</p><p>​            - 解决：增加对当前线程的判断，如果同一个线程，可以进入；否则等待</p><p>​        - Reentrant.java  可以重入</p><p>​    - 锁的可重入性</p><p>​        - Java中的synchronized同步块是可重入的。这意味着如果一个java线程进入了代码中的synchronized同步块，并因此获得了该同步块使用的同步对象对应的管程上的锁，那么这个线程可以进入由同一个管程对象所同步的另一个java代码块。</p><p>​        - 如果一个线程已经拥有了一个管程对象上的锁，那么它就有权访问被这个管程对象同步的所有代码块。这就是可重入。</p><p>​        - 当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果摸个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是调用。重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程所持有，当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1，如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁将被释放。</p><p>​    - 锁的公平性</p><p>​        - synchronized块并不保证尝试进入它们的线程的顺序。因此可能出现线程饥饿现象。需要额外实现，保证公平性</p><p>​    - 在finally语句中调用unlock()</p><p><strong>###### 饥饿与公平</strong></p><p>\1. 饥饿：如果一个线程因为CPU时间全部被其他线程抢走而得不到CPU运行时间，这种状态被称之为“饥饿”。</p><p>​    - 原因：</p><p>​        - 高优先级线程吞噬所有的低优先级线程的CPU时间。</p><p>​        - 线程被永久堵塞在一个等待进入同步块的状态。</p><p>​        - 线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的wait方法)。</p><p>​    - 解决方式</p><p>​        - 使用锁，而不是同步块</p><p>​        - 公平锁</p><p>​        - 注意性能方面 </p><p>​        - <a href="http://ifeve.com/starvation-and-fairness/" target="_blank" rel="noopener">参考资料</a>   </p><p><strong>###### 嵌套管程死锁</strong></p><p>死锁中，二个线程都在等待对方释放锁。</p><p>嵌套管程锁死中，线程1持有锁A，同时等待从线程2发来的信号，线程2需要锁A来发信号给线程1。</p><p><strong>###### 读写锁</strong></p><p>Java5在java.util.concurrent包中已经包含了读写锁。</p><p><strong>###### 信号量</strong></p><p>Semaphore（信号量） 是一个线程同步结构，用于在线程间传递信号，以避免出现信号丢失（译者注：下文会具体介绍），或者像锁一样用于保护一个关键区域。自从5.0开始，jdk在java.util.concurrent包里提供了 Semaphore 的官方实现，因此大家不需要自己去实现Semaphore。但是还是很有必要去熟悉如何使用Semaphore及其背后的原理</p><p>\1. Semaphore的实现</p><p>\2. 使用Semaphore</p><p>\3. 可计数的Semaphore</p><p>\4. 有上限的Semaphore</p><p>\5. 把Semaphore当锁来使用</p><p><strong>### 同步方法和同步块，哪个是更好的选择</strong></p><p>\1. 同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。</p><p>\2. 但是借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做<strong><em>\</em>锁粗化**</strong>的优化方法，<strong><em>\</em>这种方法就是把同步范围变大**</strong>。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。</p><p>- 阻塞队列实现，BlockingQueue</p><p>- sync关键字实现，</p><p>- lock实现， </p><p>- reentrantLock等 </p><p>\1. 乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换CAS这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p><p>\2. 悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p><p><strong>### 写出生产者消费者模式</strong></p><p><strong>### Concurrent包里的其他东西：ArrayBlockingQueue  CountDownLatch</strong></p><p>- sleep()方法是线程类（Thread）的静态方法，导致此线程暂停执行指定时间，将执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复（线程回到就绪（ready）状态），因为调用sleep 不会释放对象锁。</p><p>- wait()是Object 类的方法，对此对象调用wait()方法导致本线程放弃对象锁(线程暂停执行)，进入等待此对象的等待锁定池，只有针对此对象发出notify 方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入就绪状态。</p><p>- join方法用线程实例对象调用，如果在一个线程A中调用另一个线程B的join方法，线程A将会等待线程B执行完毕后再执行。</p><p>- yield()可以直接用Thread类调用，yield()让出CPU执行权给同等级的线程，如果没有相同级别的线程在等待CPU的执行权，则该线程继续执行。</p><p><strong>### 线程中断</strong></p><p>- 使用interrupt()中断线程：当一个线程运行时，另一个线程可以调用对应的Thread对象的interrupt（）方法来中断它，该方法只是在目标线程中设置一个标志，表示它已经被中断，并立即返回。这里需要注意的是，如果只是单纯的调用interrupt（）方法，线程并没有实际被中断，会继续往下执行</p><p>- 待决中断：如果线程在调用sleep（）方法前就被中断，那么该中断称为待决中断，它会在刚调用sleep（）方法时，立即抛出InterruptedException异常。</p><p>- </p><p>\<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">​    public class PendingInterrupt extends Object&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​        public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">​            //如果输入了参数，则在main线程中中断当前线程（即main线程）</span><br><span class="line"></span><br><span class="line">​            if(args.length &gt; 0)&#123;</span><br><span class="line"></span><br><span class="line">​                Thread.currentThread().interrupt();</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​            //获取当前时间</span><br><span class="line"></span><br><span class="line">​            long startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">​            try &#123;</span><br><span class="line"></span><br><span class="line">​                Thread.sleep(2000);</span><br><span class="line"></span><br><span class="line">​                System.out.println(&quot;was NOT interrupted&quot;);</span><br><span class="line"></span><br><span class="line">​            &#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">​                System.out.println(&quot;was interrupted&quot;);</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​            //计算中间代码执行的时间</span><br><span class="line"></span><br><span class="line">​            System.out.println(&quot;elapsedTime=&quot; + (System.currentTimeMillis() - startTime));</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">\</span><br></pre></td></tr></table></figure></p><p>这种模式下，main线程中断它自身。除了将中断标志（它是Thread的内部标志）设置为true外，没有其他任何影响。线程被中断了，但main线程仍然运行，main线程继续监视实时时钟，并进入try块，一旦调用sleep（）方法，它就会注意到待决中断的存在，并抛出InterruptException。于是执行跳转到catch块，并打印出线程被中断的信息。最后，计算并打印出时间差。</p><p>- 使用isInterrupted（）方法判断中断状态</p><p>可以在Thread实例对象上调用isInterrupted（）方法来检查任何线程的中断状态。这里需要注意：线程一旦被中断，isInterrupted（）方法便会返回true，而一旦sleep（）方法抛出异常，它将清空中断标志，此时isInterrupted（）方法将返回false。</p><p>- 使用Thread.interrupted（）方法判断中断状态</p><p>可以使用Thread.interrupted（）方法来检查当前线程的中断状态（并隐式重置为false）。又由于它是静态方法，因此不能在特定的线程上使用，而只能报告调用它的线程的中断状态，如果线程被中断，而且中断状态尚不清楚，那么，这个方法返回true。与isInterrupted（）不同，它将自动重置中断状态为false，第二次调用Thread.interrupted（）方法，总是返回false，除非中断了线程。</p><p><strong>### 守护线程与阻塞线程</strong></p><p>\1. 用户线程：即运行在前台的线程</p><p>\2. 守护线程：是运行在后台的线程</p><p>​    - 守护线程作用是为其他前台线程的运行提供便利服务，而且仅在普通、非守护线程仍然运行时才需要，比如垃圾回收线程就是一个守护线程。当VM检测仅剩一个守护线程，而用户线程都已经退出运行时，VM就会退出，因为如果没有了守护者，也就没有继续运行程序的必要了。如果有非守护线程仍然活着，VM就不会退出。</p><p>​    - 守护线程并非只有虚拟机内部提供，用户在编写程序时也可以自己设置守护线程。用户可以用Thread的setDaemon(true)方法设置当前线程为守护线程。</p><p>​        - setDaemon(true)必须在调用线程的start()方法之前设置，否则会跑出IllegalThreadStateException异常。</p><p>​        - 在守护线程中产生的新线程也是守护线程</p><p>​        - 不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。</p><p>\3. 线程阻塞：</p><p>​    - （可中断）当线程执行Thread.sleep()时，它一直阻塞到指定的毫秒时间之后，或者阻塞被另一个线程打断</p><p>​    - （可中断）当线程碰到一条wait()语句时，它会一直阻塞到接到通知(notify())、被中断或经过了指定毫秒 时间为止(若指定了超时值的话)</p><p>​    - 线程阻塞与不同的I/O的方式有多种。常见的一种方式是InputStream的read()方法，该方法一直阻塞到从流中读取一个字节的数据为止，它可以无限阻塞，因此不能指定超时时间</p><p>​    - 线程也可以阻塞等待获取某个对象锁的排它性访问权限(即等待获得synchronized语句必须的锁时阻塞)</p><p><strong>### 多线程环境中安全使用集合API</strong></p><p>- public static Collection synchronizedCollention(Collection c)</p><p>- public static List synchronizedList(list l)</p><p>- public static Map synchronizedMap(Map m)</p><p>- public static Set synchronizedSet(Set s)</p><p>- public static SortedMap synchronizedSortedMap(SortedMap sm)</p><p>- public static SortedSet synchronizedSortedSet(SortedSet ss)</p><p><strong>### 并发编程中实现内存可见的两种方法比较：加锁synchronized和volatile变量</strong></p><p>\1. volatile变量是一种稍弱的同步机制在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。</p><p>\2. 从<strong><em>\</em>内存可见性**</strong>的角度看，写入volatile变量相当于退出同步代码块，而读取volatile变量相当于进入同步代码块。</p><p>\3. 在代码中如果过度依赖volatile变量来控制状态的可见性，通常会比使用锁的代码更脆弱，也更难以理解。仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它。一般来说，用同步机制会更安全些。</p><p>\4. 加锁机制（即同步机制）<strong><em>\</em>既可以确保可见性又可以确保原子性**</strong>，而<strong><em>\</em>volatile变量只能确保可见性**</strong>，原因是声明为volatile的简单变量如果当前值与该变量以前的值相关，那么volatile关键字不起作用，也就是说如下的表达式都<strong><em>\</em>不是原子操作**</strong>：“count++”、“count = count+1”。</p><p>​    - 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</p><p>​    - 该变量没有包含在具有其他变量的不变式中。</p><p>总结：在需要同步的时候，第一选择应该是synchronized关键字，这是最安全的方式，尝试其他任何方式都是有风险的。尤其在、jdK1.5之后，对synchronized同步机制做了很多优化，如：自适应的自旋锁、锁粗化、锁消除、轻量级锁等，使得它的性能明显有了很大的提升。</p><p>从Java1.4开始，引入NIO，提供了与标准IO不同的IO工作方式。</p><p>\1. </p><p>​    - 标准io：基于字节流和字符流进行操作的</p><p>​    - NIO：基于通道(Channel)和缓冲区(Buffer)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入通道也类似。</p><p>​        - NIO由以下核心部分组成：</p><p>​            - Channels：</p><p>​                - Channel有点像流。数据可以从Channel读到Buffer中，也可以从Buffer写到Channel中。但流的读写通常是单向的。</p><p>​                - 通道可以异步的读写。</p><p>​                - 通道的数据总是要先读到一个Buffer，或者总要从一个Buffer中写入。</p><p>​                - FileChannel 从文件中读取数据</p><p>​                - DatagramChannel  能通过UDP读写网络中的数据</p><p>​                - SocketChannel 能通过TCP读写网络中的数据</p><p>​                - ServerSocketChannel 可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel</p><p>​            - Buffers</p><p>​                - ByteBuffer</p><p>​                - CharBuffer</p><p>​                - DoubleBuffer</p><p>​                - FloatBuffer</p><p>​                - IntBuffer</p><p>​                - LongBuffer</p><p>​                - ShortBuffer</p><p>​                - MappedByteBuffer，用于表示内存映射文件</p><p>​            - Selectors：Selector允许单线程处理多个Channel</p><p>\2. nio：Non-blocking IO（非阻塞IO）。Java NIO可以让你非阻塞的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。</p><p>\3. Java NIO: Selectors(选择器)。Java NIO引入了选择器的概念，选择器用于监听多个通道的事件(比如：连接打开，数据到达)。因此，单个的线程可以监听多个数据通道。</p><p>\1. 给你的线程起个有意义的名字，这样可以方便找bug或追踪。</p><p>\2. 根据具体的使用场景，选择锁定和缩小同步的范围（或小，或大（考虑StringBuffer append使用场景 就是用到锁粗化））</p><p>\3. 多用同步类少用wait 和 notify。CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。</p><p>\4. 多用并发集合少用同步集合</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;作为常用java语言开发的从业人员，怎么能不了解java的并发呢？那么我们一点一点开始讲起。&lt;/p&gt;
&lt;h1 id=&quot;进程与线程&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="java" scheme="http://wenchaos.com/categories/java/"/>
    
    
      <category term="java" scheme="http://wenchaos.com/tags/java/"/>
    
      <category term="并发" scheme="http://wenchaos.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java后端搭建初稿</title>
    <link href="http://wenchaos.com/java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%90%8E%E7%AB%AF%E6%90%AD%E5%BB%BA%E5%88%9D%E7%A8%BF/"/>
    <id>http://wenchaos.com/java后端开发/java后端搭建初稿/</id>
    <published>2018-06-08T16:00:00.000Z</published>
    <updated>2019-07-28T07:55:25.082Z</updated>
    
    <content type="html"><![CDATA[<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ol><li>java基础知识</li><li>Servlet与jsp基础知识</li><li>Spring+SpringMVC+Mybatis使用</li><li>Redis使用</li></ol><h3 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h3><ol><li>intellij idea：ide</li><li>tomcat或者jetty：server容器</li><li>Navicat premiun:管理数据库</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;java基础知识&lt;/li&gt;
&lt;li&gt;Servlet与jsp基础知识&lt;/li&gt;
&lt;li&gt;Spring+Spring
      
    
    </summary>
    
      <category term="后端开发" scheme="http://wenchaos.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java，后端开发" scheme="http://wenchaos.com/tags/java%EF%BC%8C%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>c++是一门值得学习的语言呢</title>
    <link href="http://wenchaos.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c++%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://wenchaos.com/编程语言/c++语言入门总结/</id>
    <published>2018-05-08T16:00:00.000Z</published>
    <updated>2019-07-28T14:02:04.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文内容主要来自《C++ Primer Plus》</p><h1 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h1><h2 id="第一章摘要"><a href="#第一章摘要" class="headerlink" title="第一章摘要"></a>第一章摘要</h2><ol><li>面向过程与面向对象</li><li>几种c++编译器的使用方法</li></ol><h2 id="第二章摘要（无）"><a href="#第二章摘要（无）" class="headerlink" title="第二章摘要（无）"></a>第二章摘要（无）</h2><h2 id="第三章摘要"><a href="#第三章摘要" class="headerlink" title="第三章摘要"></a>第三章摘要</h2><ol><li>数据类型</li><li>数据类型之间的转换</li></ol><h2 id="第四章摘要"><a href="#第四章摘要" class="headerlink" title="第四章摘要"></a>第四章摘要</h2><ol><li>复合类型<ol><li>数组</li><li>结构</li><li>指针</li></ol></li><li>内存分配的一些方法</li></ol><h2 id="第五章摘要"><a href="#第五章摘要" class="headerlink" title="第五章摘要"></a>第五章摘要</h2><ol><li>循环 <ol><li>for</li><li>while</li><li>do while</li></ol></li><li>关系表达式</li></ol><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><ol><li>分支语句<ol><li>if else </li><li>switch</li></ol></li><li>逻辑运算符</li></ol><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><ol><li>函数<ol><li>c++和c函数的共同特性</li><li>函数定义</li><li>函数原型</li></ol></li><li>函数指针</li></ol><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><ol><li>c++中函数的新增特性<ol><li>内联函数</li></ol></li></ol><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><ol><li>内存模型</li><li>名称空间</li></ol><h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><ol><li>对象和类</li></ol><h2 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h2><ol><li>运算重载符</li></ol><h1 id="重点部分"><a href="#重点部分" class="headerlink" title="重点部分"></a>重点部分</h1><ol><li>类和对象</li><li>继承</li><li>多态，虚函数和RTTI（运行时类型识别）</li><li>函数重载</li><li>引用变量</li><li>泛型（独立于类型的）编程</li><li>处理错误的异常机制</li><li>管理函数，类和变量名的名称空间</li></ol><h1 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文内容主要来自《C++ Primer Plus》&lt;/p&gt;
&lt;h1 id=&quot;基础部分&quot;&gt;&lt;a href=&quot;#基础部分&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="c++" scheme="http://wenchaos.com/categories/c/"/>
    
    
      <category term="编程语言" scheme="http://wenchaos.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>同步与异步</title>
    <link href="http://wenchaos.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
    <id>http://wenchaos.com/计算机基础/同步与异步/</id>
    <published>2018-04-15T16:00:00.000Z</published>
    <updated>2019-07-28T07:54:46.703Z</updated>
    
    <content type="html"><![CDATA[<p>在讲到同步，异步，并发，并行，阻塞与非阻塞这些概念的时候，一定会涉及到进程与线程的相关概念。因此需要先了解一下进程与线程。</p><p>#进程与线程</p><ol><li>进程（Process）：具有独立功能的程序在某个数据集合上的一次运行活动；是OS进行资源分配和保护的基本单位。</li><li>线程（Thread）：</li><li>区别：<ol><li>进程是系统资源分配的基本单位，线程是cpu调度，程序执行的最小单位。</li><li>进程有独立的地址空间，而同一进程中的线程共享改进程的地址空间。</li><li>线程间通信</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在讲到同步，异步，并发，并行，阻塞与非阻塞这些概念的时候，一定会涉及到进程与线程的相关概念。因此需要先了解一下进程与线程。&lt;/p&gt;
&lt;p&gt;#进程与线程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程（Process）：具有独立功能的程序在某个数据集合上的一次运行活动；是OS进行资源分配和保
      
    
    </summary>
    
      <category term="java" scheme="http://wenchaos.com/categories/java/"/>
    
    
      <category term="并发" scheme="http://wenchaos.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github搭建个人博客攻略</title>
    <link href="http://wenchaos.com/%E5%B7%A5%E5%85%B7%E7%AF%87/hexo+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%94%BB%E7%95%A5/"/>
    <id>http://wenchaos.com/工具篇/hexo+github搭建博客攻略/</id>
    <published>2018-04-09T16:00:00.000Z</published>
    <updated>2019-05-06T15:24:04.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>随着国内开发者水平的提高，以及各个技术博客的平台相继出现。有些人更愿意将写的博客记录在自己的平台上，故而引出本文。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;随着国内开发者水平的提高，以及各个技术博客的平台相继出现。有些人更愿意将写的博客记录在自己的平台上，故而引出本文。&lt;/p&gt;

      
    
    </summary>
    
      <category term="工具，" scheme="http://wenchaos.com/categories/%E5%B7%A5%E5%85%B7%EF%BC%8C/"/>
    
    
      <category term="工具，hexo，github" scheme="http://wenchaos.com/tags/%E5%B7%A5%E5%85%B7%EF%BC%8Chexo%EF%BC%8Cgithub/"/>
    
  </entry>
  
  <entry>
    <title>c是一门值得学习的语言呢</title>
    <link href="http://wenchaos.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://wenchaos.com/编程语言/c语言入门总结/</id>
    <published>2018-04-08T16:00:00.000Z</published>
    <updated>2019-07-13T09:55:28.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="3。数据类型"><a href="#3。数据类型" class="headerlink" title="3。数据类型"></a>3。数据类型</h1><ol><li>2.<br>3.</li><li><p>实型数据（又称浮点类型）</p><ul><li>实型常量的表示方法<ol><li>小数形式</li><li>指数形式</li></ol></li><li>实型变量<ol><li>在内存中的存放形式<ul><li>一般占4个字节byte（32位）</li></ul></li><li>实型变量的分类<ol><li>单精度float：4个字节</li><li>双精度double：8个字节</li><li>长双精度long double: </li></ol></li></ol></li></ul></li><li><p>结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct st&#123;</span><br><span class="line">    int a;//成员a</span><br><span class="line">    int b;//成员b</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>枚举</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum em&#123;</span><br><span class="line">    red=0,</span><br><span class="line">    green,</span><br><span class="line">    black</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>文件操作</p><ol><li>文件类型 FILE* file</li><li>打开文件 FILE* fopen(path,mode)</li><li>fwrite/fread</li><li>fclose</li><li>文件游标操作 rewind</li></ol></li><li><p>指针</p><ol><li>它就是变量在内存中的一个地址；</li><li>指针本身的运算；</li><li>指针所指的内容的运算；</li></ol></li></ol><ol><li><p>操作系统如何管理内存；</p><ol><li>内核空间</li><li>栈控件；</li><li>引用库</li><li>堆空间</li><li>内存映射</li><li><p>内存的分配与释放；</p><ol><li>分配： void* mem = malloc(size);</li><li>释放：free(mem);</li></ol></li><li><p>内存泄漏与野指针</p><ol><li>不断的向系统申请内存；</li><li>申请内存不用，也不释放；</li><li>占用别人的内存成为野指针；</li></ol></li></ol></li><li><p>函数指针</p><ol><li>返回值类型 (* 指针变量名)([形参列表])<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int func(int x)函数</span><br><span class="line">int （*f）(int x);</span><br><span class="line">f =func;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>编译器；</p><ol><li>gcc：linux下的编译器</li><li>clang：mac下使用的编译器</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gcc/clang -g -O2 -o test test.c -I</span><br><span class="line">注释：</span><br><span class="line">1. -g:输出文件中的调试信息；</span><br><span class="line">2. -O：对输出文件做指令优化；</span><br><span class="line">3. -o：输出文件</span><br><span class="line">4. -I：指定头文件；</span><br><span class="line">5. -L：指定三方库文件位置；</span><br><span class="line">6. -l:指定使用哪个库</span><br></pre></td></tr></table></figure></li><li><p>编译过程：</p><ol><li>预编译：#\&lt;include>，将引用到文件，头文件加载</li><li>编译</li><li>链接：将系统库和三方库 与编译好的项目代码进行合并<ol><li>动态链接：代码执行中进行链接</li><li>静态链接: </li></ol></li></ol></li></ol></li><li><p>调试器</p><ol><li>gdb：</li><li>lldb：</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h1 id=&quot;3。数据类型&quot;&gt;&lt;a href=&quot;#3。数据类型&quot; class=&quot;headerlink&quot; title=&quot;3。数据类型&quot;&gt;&lt;/a&gt;3
      
    
    </summary>
    
      <category term="java" scheme="http://wenchaos.com/categories/java/"/>
    
    
      <category term="并发" scheme="http://wenchaos.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频入门基础</title>
    <link href="http://wenchaos.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/"/>
    <id>http://wenchaos.com/音视频基础/音视频入门基础/</id>
    <published>2018-04-08T16:00:00.000Z</published>
    <updated>2019-06-12T13:57:54.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><h2 id="1-1音视频知识"><a href="#1-1音视频知识" class="headerlink" title="1.1音视频知识"></a>1.1音视频知识</h2><ol><li>音视频采集</li><li>音视频硬软编解码</li><li>FFmpeg</li><li>WebRTC</li><li>音视频处理架构</li><li>网络传输</li></ol><h1 id="2-音频入门基础"><a href="#2-音频入门基础" class="headerlink" title="2.音频入门基础"></a>2.音频入门基础</h1><h1 id="3-视频入门基础"><a href="#3-视频入门基础" class="headerlink" title="3.视频入门基础"></a>3.视频入门基础</h1><ol><li>视频基本知识</li><li>H264宏块的划分与帧分组</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h1&gt;&lt;h2 id=&quot;1-1音视频知识&quot;&gt;&lt;a href=&quot;#1-1音视频知识&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
      <category term="java" scheme="http://wenchaos.com/categories/java/"/>
    
    
      <category term="并发" scheme="http://wenchaos.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ffmepg中的文件操作</title>
    <link href="http://wenchaos.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/FFmpeg/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://wenchaos.com/音视频基础/FFmpeg/文件操作/</id>
    <published>2018-04-08T16:00:00.000Z</published>
    <updated>2019-07-13T10:12:31.862Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>文件创建和删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;libavformat/&gt;avformat.h&gt;</span><br><span class="line">#include &lt;libavutil/log.h&gt;</span><br><span class="line"></span><br><span class="line">//删除文件</span><br><span class="line">int ret = avpriv_io_delete(filepath);</span><br><span class="line">   </span><br><span class="line">// 重命名文件</span><br><span class="line">avpriv_io_move(sourcefilename,targetfilename);</span><br><span class="line"></span><br><span class="line">//操作目录</span><br><span class="line">avio_open_dir();</span><br><span class="line">//</span><br><span class="line">avio_read_dir();</span><br><span class="line">//</span><br><span class="line">avio_close_dir();</span><br><span class="line">//</span><br><span class="line">avio_free_directory_entry();</span><br></pre></td></tr></table></figure></li><li><p>重要结构体</p><ol><li>AVIODirContext:操作目录的上下文；</li><li>AVIODirEntry: 目录项。 用于存放文件名，文件大小信息</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;文件创建和删除&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
      <category term="ffmpeg" scheme="http://wenchaos.com/categories/ffmpeg/"/>
    
    
      <category term="ffmpeg" scheme="http://wenchaos.com/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>http的一路历程</title>
    <link href="http://wenchaos.com/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/http%E7%9A%84%E4%B8%80%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    <id>http://wenchaos.com/网络基础/http的一路历程/</id>
    <published>2018-04-04T16:00:00.000Z</published>
    <updated>2019-07-28T01:57:18.619Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP诞生于1991年，是互联网领域一个基石性的协议。全世界电脑上的内容能互联起来，全拜HTTP所赐。因此好好的学习了解一下是必不可少的。</p><h1 id="TCP-IP的分层管理"><a href="#TCP-IP的分层管理" class="headerlink" title="TCP/IP的分层管理"></a>TCP/IP的分层管理</h1><pre><code>这里呢其实有两种分层的方式，一种是</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HTTP诞生于1991年，是互联网领域一个基石性的协议。全世界电脑上的内容能互联起来，全拜HTTP所赐。因此好好的学习了解一下是必不可少的。&lt;/p&gt;
&lt;h1 id=&quot;TCP-IP的分层管理&quot;&gt;&lt;a href=&quot;#TCP-IP的分层管理&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="网络" scheme="http://wenchaos.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="http" scheme="http://wenchaos.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Android开发需要知道gradle的常用知识</title>
    <link href="http://wenchaos.com/android%E5%BC%80%E5%8F%91/Android%E5%BC%80%E5%8F%91%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93gradle%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86/"/>
    <id>http://wenchaos.com/android开发/Android开发需要知道gradle的常用知识/</id>
    <published>2018-03-27T16:00:00.000Z</published>
    <updated>2018-04-21T08:04:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>#</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#&lt;/p&gt;

      
    
    </summary>
    
      <category term="工具类" scheme="http://wenchaos.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
      <category term="gradle" scheme="http://wenchaos.com/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Java的常用知识整理</title>
    <link href="http://wenchaos.com/java%E5%9F%BA%E7%A1%80%E7%AF%87/java%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>http://wenchaos.com/java基础篇/java的常用知识整理/</id>
    <published>2018-03-27T16:00:00.000Z</published>
    <updated>2019-07-28T07:55:34.213Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Java主要方面<ol><li>面向对象的特性</li><li>集合（特点，数据结构（数组，栈，队列，双向队列，红黑树，二叉树等））</li><li>JVM虚拟机（加载机制/内存以及垃圾回收）</li><li>线程与进程，异步</li><li>注解/反射/泛型</li><li>设计模式（单例，建造者，适配器，工厂，策略，观察者，代理）</li><li>算法（数据结构/排序，查找等）</li></ol></li><li>面向对象的特征<ol><li>抽象：针对某一类对象的共同特征总结出来构造类的过程，抽象只关注对象有哪些共同的属性和行为，而不关心具体内容<ol><li>数据抽象</li><li>行为抽象</li></ol></li><li>继承：从已有类得到继承信息创建新类的过程。</li><li>封装：通常认为封装是把数据和行为绑定起来，对数据的访问只能通过定义的接口。封装就是隐藏一切可以隐藏的东西，只向外界提供最简单的编程接口。</li><li>多态性：指的是允许不同子类型的对象对同一消息作出不同的行为。即同样的对象引用调用同样的方法，但是做了不同的事情。<ol><li>编译时多态：方法重载（前期绑定），同一个类中，同名方法不同参；对返回值没有要求</li><li>运行时多态：方法重写（后期绑定），<ol><li>父子类中，即 子类继承父类已有的或者抽象的方法；</li><li>返回类型相同，</li><li>修饰符权限更开放，</li><li>不能比父类声明更多的异常（里氏替换原则）</li><li>方法重写，2. 对象造型（向下）即：用父类型引用 引用子类型对象实例，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为</li></ol></li><li>多态性的作用：<ol><li>封装：可以隐藏实现细节，便于模块化；继承可以扩展已存在的类；封装和继承都是为了代码重用性，而多态则是为了实现—接口重用！真正具有价值的重用就是“接口重用”，因为接口设计比实现接口更费时间，更花费工程师的精力。</li></ol></li></ol></li><li>问题：<ol><li>问题：从JVM/深一层的角度具体描述一下实现的机制？？？</li><li>继承与组合的不同</li></ol></li></ol></li><li>访问修饰符的区别<ol><li>public：对所有类公开，不论是不是同一包下</li><li>protect ：仅仅对同包下子类公开</li><li>default：默认对于同一个包下的其他类相当于public，非同一个包下的相当于private</li><li>private：仅仅当前类中可以访问到</li></ol></li><li>java面试题180 <ol><li>（上） <a href="http://blog.csdn.net/jackfrued/article/details/44921941" target="_blank" rel="noopener">http://blog.csdn.net/jackfrued/article/details/44921941</a>  例：</li><li>String是基本类型吗？答：不是，基本类型有八种：byte ,short , int , long , double , float , char , boolean; 其他的都是引用类型，Java5引入的枚举enum也属于引用类型</li></ol></li><li>解释内存中的栈（stack）堆（heap）和方法区（method area）<ol><li>栈空间：通常基本数据类型，对象的引用，以及函数调用的现场保存 </li><li>堆空间：通过new或者构造器创建的对象 （垃圾回收的主要区域，因为垃圾回收器大多数采用分代收集算法，所以堆空间还细分了 新生代，老生代）</li><li>方法区：</li><li>方法区和堆空间都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息，常量，静态变量，JIT编译器编译后的代码等数据；</li><li>程序中的字面量，如100，“Hello”和常量都是放在常量池中，常量池是方法区的一部分</li><li>栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数进行调整</li><li>栈空间用光了会引发StackOverflowError，而堆空间和常量池不足则会引发OutOfMemoryError</li><li>例子：String str = new String（“Hello”）中，变量str，作为引用，放在栈中；new创建的字符串对象放在堆上，而“Hello”这个字面量放在方法区</li><li>补充：<ol><li>Java6 开始，由于JIT编译器的发展和“逃逸技术”逐渐成熟，栈上分配，标量替换等优化技术使得对象不一定非得分配在堆中；</li><li>运行时常量池相当于Class文件常量池具有动态性，Java语言并不要求常量一定只有编译器才能产生，运行期也可以将新的常量放入池中，String的intern()方法就是这样；</li></ol></li></ol></li><li>switch能否作用在byte，long上？String呢；（为什么？？？）<ol><li>答：Java 5 以前只能是byte ，short，char，int ；java 5 开始引入enum；Java 7 开始引入String；而long不可以；</li></ol></li><li>两个对象值相同（x.equals(y) == true），但却可以有不同的hash code吗？<ol><li>答：不对；Java对于equals方法和hashcode方法是这样规定：</li><li>如果两个对象相同（x.equals(y) == true），那么他们的hashCode值一定要相同；</li><li>如果两个对象hashCode相同，他们不一定相同；</li><li>补充：如果违背了java的这种规则，就会发现：在使用容器时，相同的对象可以set集合中出现，同时增加新元素的效率大大下降（这是因为使用哈希存储的系统，如果哈希码频繁的冲突，将会造成存取性能的急剧下降）</li><li>补充：equals方法必须满足：自反性，对称性，传递性，一致性</li><li>补充：重写equals方法的优秀要求：<ol><li><ol><li>使用==操作符检查”参数是否为这个对象的引用”；</li></ol></li><li><ol><li>使用instanceof操作符检查”参数是否为正确的类型”；</li></ol></li><li><ol><li>对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；</li></ol></li><li><ol><li>编写完equals方法后，问自己它是否满足对称性、传递性、一致性；</li></ol></li><li><ol><li>重写equals时总是要重写hashCode；</li></ol></li><li><ol><li>不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。  </li></ol></li></ol></li></ol></li><li>String和StringBuilder StringBuffer的区别<ol><li>String：不可变，只读</li><li>StringBuilder：可修改，Java 5引入，单线程，因为没有被做线程安全的处理，所以效率比StringBuffer高</li><li>StringBuffer：可修改，多线程安全，效率相对低</li><li>补充：什么情况下用 +运算符进行字符串连接，比用StringBuffer和StringBuilder性能好；<ol><li>+运算符的操作本质是创建了StringBuilder对象进行append操作，然后将结果toString</li></ol></li></ol></li><li>描述一下JVM加载class文件的原理机制<ol><li>JVM中类的装载是由类加载器（classLoader）和他的子类来实现的；是java运行时系统的一个重要组件，负责在运行时查找和装入类文件</li><li>由于java的跨平台型，经过编译的java源程序并不是一个可执行程序，而是一个或多个中间文件。</li><li>当java程序需要某个文件时，JVM会确保这个类已经被加载–&gt;链接（验证—&gt; 准备—&gt;解析）—&gt;初始化。类的加载是指把类的.class文件读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。</li><li>加载完成后，Class对象还不完整，还不可用。被加载后，进入连接过程，包括验证，，准备（为静态变量分配内存，设置初始值）和解析（将符号引用替换成直接引用）。</li><li>最后JVM对类进行初始化。如果该类存在直接的父类并且这个父类也还没有被初始化，则先初始化父类；如果该类中存在初始化语句，就依次执行这些初始化语句</li><li>类加载器：<ol><li>根加载器：Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）（不是java语言所编写的）</li><li>扩展加载器：Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；</li><li>系统加载器：System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</li><li>用户自定义加载器：</li><li>加载流程：应用启动：JVM启动—&gt;bootstrap classloader运行，加载java运行的核心类库，同时加载扩展加载器和系统加载器；—&gt;扩展加载器去加载扩展Api，—&gt;app classloader 加载CLASSPATH 目录下定义的class，通常没有特别指定的情况下，程序自定义类文件有系统加载器加载。</li></ol></li><li>双亲委托模式：<ol><li>优先判断父类加载器是否已经加载class文件，如果没有则子类进行；若parent classloader为null ，则调用 bootstrap classloader进行加载</li><li>优缺点：<ol><li>避免重复加载</li><li>安全问题：如果不适用这个模式，则有可能造成外来类替换java核心类的安全隐患</li></ol></li><li>流程：<ol><li>入口在ClassLoader.loadClass(name,boolean resolve):类名称，是否需要解析类；在执行类之前，需要考虑是否需要解析类，并不总是需要解析，如果JVM只需要知道该类是否存在或找出该类的超类，则不需要解析</li><li>defineClass<ol><li>接受由原始字节组成的数组，并将之转成Class对象。原始数组包含从文件系统或者网络装入的数据。defineClass管理JVM的许多复杂实现，它把字节码分析成运行时数据结构，校验有效性等。该方法为finla，不可重写</li></ol></li><li>findSystemClass方法<ol><li>从本地文件系统装入</li></ol></li></ol></li></ol></li><li>Class.forName 与classloader加载的类文件有什么区别<ol><li>loadClass加载 类实际上是在加载的时候并不对该类进行解析，因此不会初始化该类；而Class.forName则想反，在forName加载的时候就会将Class进行解析以及初始化！</li></ol></li></ol></li><li>抽象类与接口的区别：<ol><li>相同点：<ol><li>不能被实例化</li><li>可以定义抽象类和接口类型的引用</li></ol></li><li>不同点：<ol><li>抽象类：可以有构造器；可以有抽象方法，具体方法；不一定有抽象方法；可以有private、默认、protected、public的成员变量</li><li>接口：没有构造器；只能有抽象方法；只能是常量 public static final ；没有静态方法</li><li>在继承体系中，抽象类继承是属于is-a的关系；接口的实现属于has-a的关系</li></ol></li><li>语法层面上的区别<ol><li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的</li><li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ol></li><li>设计层面上的区别<ol><li>抽象层次不同：抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象</li><li>跨域不同，抽象类作为很多子类的父类，它是一种具有相似特点的类。而接口是一种行为规范，它可以跨多种域，它是一种辐射式设计</li><li>设计层次不同：对于抽象类，它是自子类而父类来设计（自下而上），先知道子类才能抽象出父类，而接口不同，接口只是定义一种行为，不管行为的具体实施。</li></ol></li></ol></li><li>集合部分<ol><li>Collection：Java不提供直接继承Collection<ol><li>List：有序，索引，可重复<ol><li>ArrayList：<ol><li>允许所有元素，包括null</li><li>不是线程安全</li></ol></li><li>LinkedList：<ol><li>允许null元素，</li><li>常常被用作stack，queue，deque（双向队列）</li><li>不是线程安全！一种解决方法是在创建List时构造一个同步的List：List list = Collections.synchronizedList(new LinkedList(…));</li></ol></li><li>Vector：线程安全！非常类似ArrayList<ol><li>Stack：实现一个后进先出的堆栈；push，pop，peak，empty，search</li></ol></li></ol></li><li>Set：无重复<ol><li>HashSet</li><li>TreeSet</li><li>LinkedHashSet</li></ol></li><li>Queue<ol><li>PriorityQueue</li></ol></li><li>Collection类型的集合都支持iterator()方法，该方法返回一个Iterator it = collection.iterator(); // 获得一个迭代子</li></ol></li><li>Map：内部一个K-V映射的哈希表，由于作为key的对象将通过计算其散列值来确定与之对应的value的位置，因此任何作为key的对象必须实现hashCode，equals方法<ol><li>HashMap：键值对允许null，</li><li>HashTable：键值对非null，同步的</li><li>WeakHashMap：</li><li>TreeMap与TreeSet：<ol><li>TreeMap继承Map，TreeSet继承Set，TreeSet底层是通过TreeMap来实现的（如同HashSet底层是通过HashMap还实现的）</li><li>TreeMap的实现就是红黑树算法</li><li>相同点：<ol><li>都是有序集合，存储的值都是排好序的；</li><li>都是非同步集合，不能在多线程环境中使用，（可以使用Collections.synchronizedMap()进行同步化）</li><li>运行速度都要比hash集合慢，内部对元素的操作 时间复杂度为O(logN)，而HashMap/HashSet则为O(1)。因为一个是树结构，一个数组结构</li></ol></li><li>不同点：<ol><li>主要区别是实现接口不一样；</li><li></li></ol></li></ol></li></ol></li><li>涉及到堆栈，队列：list</li></ol></li><li>同步异步<ol><li>Synchronized，volatile，</li><li>java.util.concurrent.locks.Lock</li><li>Semaphore信号量</li><li>FutureTask：<ol><li>类似Runnable，都可以通过Thread来启动；不同的是FutureTask可以返回执行完毕后的数据，并且get（）是阻塞的；</li><li>可用于进行资源的预处理/预加载</li></ol></li><li>CyclicBarrier：可以阻塞一组线程，当同时满足条件后，才能解除阻塞继续执行下面的操作；单个线程中调用await（）并不管用；</li><li>Executor：线程池</li><li>Timer：定时器（偏向于单个任务）<ol><li>缺陷<ol><li>对于多个任务，timer内部只有一个任务线程，所以某个任务执行时间过长，导致不能按照我们定时器预定的执行；可以用ScheduledThreadPool弥补</li><li>一旦TimerTask出现了异常，Timer会停止所有任务的运行</li></ol></li></ol></li></ol></li><li>序列化以及意义：<ol><li>用来处理对象流的一种机制，所谓对象流也就是将对象的内容进行流化，可以对流化后的对象进行读写操作，或者传输于网络之间。序列化是为了解决对象流读写操作过程中可能引发的数据乱序问题。</li><li>实现序列化需要实现Serializable接口，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆（可以参考第29题）。</li></ol></li><li>final，finally ，finalize的区别<ol><li>final 用于控制成员变量，方法，或者是一个类是否可以被覆写或继承等功能；<ol><li>成员：<ol><li>一旦初始化后，不可改变；基础类型变量：值不改变，引用类型变量：引用不可改变（其初始化的地方在 声明处或者构造器中）</li><li>对于方法参数中final，基础类型的参数没有什么实际意义；但是对于引用类型的参数，因为其传递的是对象的引用，这样你在方法中对对象变量的修改也会影响到调用语句中对象变量。当方法中不需要改变作为参数的这个对象变量时，声明为final，防止你无意中修改到它而影响到方法的调用处。</li></ol></li><li>方法：<ol><li>不能重写，但是子类可以继承</li><li>允许编译器将所有对此方法的调用转化成inline（行内）调用的机制，它会在调用方法时，直接将方法主体插入到调用处，而不是进行例行的方法调用。提高了程序效率，但是当方法主体很大的时候，反而使得插入地方迅速膨胀，反而影响了效率。</li></ol></li><li>类：<ol><li>不可被继承；其中的方法也是默认为final</li></ol></li></ol></li><li>finally：对捕获异常模型的补充，finally块始终会最后执行。finally块中的return语句会覆盖之前的return结果</li><li>finalize：根据Java语言规范，JVM保证调用finalize函数之前，这个对象是不可达的，而且JVM不保证一定会调用该方法</li></ol></li><li>传递与引用<ol><li>首先可以确定的说：Java传递的是值的副本<ol><li>基本类型变量：传递的是变量值的副本；也就是说即使副本被改变，原始变量值不会变</li><li>对象类型变量：传递的是引用的副本；因为传递的是引用，则引用内容可能会改变；</li></ol></li></ol></li><li>算法复杂度的计算：<ol><li>时间复杂度</li><li>空间复杂福</li></ol></li><li>JVM详解<ol><li>Java引用的四种状态<ol><li>强引用：new出来的对象，处于堆内存中，指向它的引用在栈中（内存空间不足，也不回收）</li><li>软引用：（内存空间足，不回收；不足，可能会随时被回收）常用来实现内存敏感的高速缓存</li><li>弱引用：每次Gc时，一旦发现有弱引用对象，不管内存是否足，都会回收</li><li>虚引用：类似于没有任何引用一样，在任何时候都可能会被回收；主要用于跟踪对象呗垃圾回收器回收的活动</li></ol></li><li>Java中内存的划分<ol><li>程序计数器：保证线程切换后能恢复到原来的执行位置 （线程私有）</li><li>jvm虚拟机栈：栈内存，为java方法服务，方法为调用 创建栈帧—&gt;局部变量表—&gt;局部变量，对象的引用，动态链接，方法出口灯（线程私有）（StackOverFlowError、OutOfMemoryError）</li><li>本地方法栈：为虚拟机运行使用到的Native方法服务（线程私有）（StackOverFlowError、OutOfMemoryError）</li><li>堆内存：存放所有new出来的对象（线程共享）（OutOfMemoryError）</li><li>方法区：存储被虚拟机JVM加载进来的类信息，常量，静态常量，静态方法等；（线程共享）</li><li>字符串常量池：方法区的一部分（线程共享）（OutOfMemoryError），一个由数组组成的表constant_pool[]用于存放Class，String以及基本类型的数据</li><li>补充：1，2，3这三个内存区域伴随线程，不需要考虑回收，线程结束，该区域自动会被回收；堆、方法区是Gc的主要战场，这里的内存分配是动态的</li><li>例子：String str = new String（“abc”）；创建了2个对象，一个在编译期创建“abc”，一个在运行期由new创建</li></ol></li><li>对象在内存中的状态<ol><li>可到达：自创建后，被一个或多个变量引用，则可达；从根节点上可触及到这个对象（引用链）</li><li>可恢复：对象不再被任何变量引用就进入了可恢复状态，回收该对象之前，会先调用finalize()方法，如果有重新有变量引用，则可达；</li><li>不可达：　Java对象不被任何变量引用，且系统在调用对象的finalize()方法后依然没有使该对象变成可达状态（该对象依然没有被变量引用），那么该对象将变成不可达状态。当Java对象处于不可达状态时，系统才会真正回收该对象所占有的资源。</li></ol></li><li>判断对象死亡的两种常用算法<ol><li>引用计数法：给对象增加一个引用计数器，0&lt;，则有引用；0&gt;，则无变量引用<ol><li>优点：算法简单，判断效率高</li><li>缺点：很难解决对象之间相互循环引用的问题</li></ol></li><li>根搜索算法：（当前采用）<ol><li>设立若干种root对象，当任何一个root对象到某个对象不可达时，则认为该对象可以被回收</li><li>root对象：<ol><li>栈（栈帧中的本地变量表）中引用的对象</li><li>方法区的静态变量</li><li>方法区中的常量引用的变量</li><li>本地方法栈中的JNI（Native方法）引用的对象</li></ol></li></ol></li></ol></li><li>垃圾回收算法<ol><li>标记-清除：<ol><li>标记阶段：标记那些从根节点开始可到达的对象，未标记的则是待回收对象</li><li>清楚阶段：清除未标记的对象</li><li>优缺点：<ol><li>标记-清除效率不高，都需要从头遍历到尾，会产生大量的不连续内存碎片</li></ol></li></ol></li><li>复制：新生代gc<ol><li>将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，然后清除正在使用的内存块中的所有对象。</li><li>优点：<ol><li>不用考虑内存碎片，只需要移动堆顶指针，按顺序分配内存即可，简单效率高</li></ol></li><li>缺点：<ol><li>空间浪费</li></ol></li><li>补充：现在的商业虚拟机都采用这种收集算法来回收新生代，新生代中的对象98%都是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块比较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。</li><li>当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖于老年代进行分配担保，所以大对象直接进入老年代。</li></ol></li><li>标记-整理：老年代的gc<ol><li>标记阶段：标记从根节点开始的可达对象</li><li>整理阶段：将所有可达对象压缩到内存的一端，之后清理边界外的所有空间</li><li>优点：<ol><li>不产生内存碎片</li></ol></li><li>缺点：<ol><li>在标记的基础上，还需要进行对象的移动，成本相对较高，效率也不高</li></ol></li></ol></li><li>分代收集算法（当前采用）<br> 1. </li></ol></li><li>垃圾回收器<ol><li>Serial收集器：Client模式下的新生代收集器</li><li>Serial old收集器：client模式下的老年代收集器</li><li>ParallNew收集器：server模式下的首选新生代收集器</li><li>G1收集器：更加关注停顿时间</li><li>CMS收集器：并发标记清除，获取最短回收停顿时间为目标，老年代收集器</li></ol></li><li>堆内存划分<ol><li>新生代</li><li>老年代</li><li>永久代</li></ol></li><li>MinorGc ，FullGc</li><li>类加载机制<ol><li>过程：</li><li>类加载器</li><li>双亲委派模型</li></ol></li></ol></li><li>内存泄漏/缓存</li><li>数据结构与排序/查找：<ol><li><ol><li>链表</li><li>栈</li><li>堆</li><li>数组</li><li>树：<ol><li>二叉树（前序，中序，后序），</li><li>平衡二叉树：</li><li>红黑树</li></ol></li><li>图：<ol><li>深度优先遍历：（有些类似二叉树的前序遍历）</li><li>广度优先遍历：（有些类似二叉树的按层次遍历）</li></ol></li><li>实现搜索引擎的搜索建议的后台技术所采用的数据结构：<ol><li>字典树，一种哈希树的变种，快速检索的多叉树。典型用于统计和排序大量的字符串等文本词频</li><li>减少无谓的字符串比较，</li><li>空间换取时间</li></ol></li></ol></li><li>排序：<ol><li>气泡排序</li><li>插入排序</li><li>二叉树排序</li><li>选择排序</li><li>堆排序</li><li>快速排序</li><li>交换排序</li><li>补充：<ol><li>记录规模较小时，n《50，可采用直接插入或直接选择排序；相反n》50，应该采用时间复杂度为O（nlogn）的排序：快速排序，堆排序</li></ol></li></ol></li></ol></li><li>反射与泛型：<ol><li>泛型：泛型的本质就是参数化类型；这种参数类型可用在接口，类，方法的创建中，分别称为泛型接口，泛型类，泛型方法</li></ol></li><li>枚举：Java1.5开始支持，java.lang.Enum为抽象类<ol><li>对Set和Map也提供支持：EnumSet EnumMap</li><li>枚举类中：常量，属性，构造方法，普通方法，抽象方法等</li><li>通过编译，生成抽象类并继承Enum，常量—&gt;final，静态$VALUES[]保存所定义的所有枚举常量；每一个定义的常量都会生成一个final内部类，里面的属性和大部分方法都是final的，通过静态代码块进行初始化，保证了枚举不可变性，不能clone，Serilizable等。</li><li>由3的产生中间类代码，可以知道：Enum相对于静态字符串常量占用的内存是比较大的</li></ol></li><li>动态代理：<ol><li></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;Java主要方面&lt;ol&gt;
&lt;li&gt;面向对象的特性&lt;/li&gt;
&lt;li&gt;集合（特点，数据结构（数组，栈，队列，双向队列，红黑树，二叉树等））&lt;/li&gt;
&lt;li&gt;JVM虚拟机（加载机制/内存以及垃圾回收）&lt;/li&gt;
&lt;li&gt;线程与进程，异步&lt;/li&gt;
&lt;li&gt;注解/反
      
    
    </summary>
    
    
      <category term="java" scheme="http://wenchaos.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>git的常用场景</title>
    <link href="http://wenchaos.com/%E5%B7%A5%E5%85%B7%E7%AF%87/git%E7%9A%84%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://wenchaos.com/工具篇/git的常用场景/</id>
    <published>2018-03-24T16:00:00.000Z</published>
    <updated>2018-04-21T07:38:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git的常用命令"><a href="#git的常用命令" class="headerlink" title="git的常用命令"></a>git的常用命令</h1><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li><p>本地仓库与git remote仓库的关联</p><ul><li>首先要在github账户上，创建与本地仓库同名的仓库repository;</li><li>进入本地仓库的根目录，开始下面一系列的操作<ol><li>可以选择创建readme.md文件；　echo “# -“ &gt;&gt; README.md</li><li>初始化该仓库；　git init</li><li>将创建的文件README.md文件放置暂存区；　git add README.md</li><li>将暂存区的修改提交; git commit -m “你的提交信息”</li><li>将本地仓库推送到github上；git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:账户名/仓库名.git,git push -u origin master</li></ol></li><li>到此已经基本完成。但是还是需要将你的电脑配置一下<ol><li>git config –global user.name “your account name”</li><li>git config –global user.email “your account email”</li><li>到此已经在当前用户配置了你的信息。下面需要生成你的ssh-key并添加到github上</li><li>生成秘钥；ssh-keygen -t rsa -C “your account email” (连续回车三次)</li><li>最后将公钥添加到git账户里，就OK啦。</li></ol></li><li><p>有时候工作环境和个人环境都需要一个秘钥，这时候可以在生成秘钥的时候，指定名字并且需要添加config文件进行指定</p><ol><li>生成指定名称的秘钥；ssh-keygen -t rsa -C “your account email” -f ~/.ssh/指定文件名</li><li><p>添加特别的配置，在ssh目录下新建config文件，内容如下</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host github-aysee</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile <span class="symbol">C:</span>/Users/username/.ssh/aysee</span><br><span class="line">你应该可以看懂的吧－－</span><br></pre></td></tr></table></figure><ol><li>在指定项目下，指定作者<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;Author name&quot;</span><br><span class="line">git config user.email &quot;Author email&quot;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ul></li><li><p>一次git提交生命过程中遇到的兄弟们（这里并不准备详细的介绍这些哥们）</p><ul><li>新建文件/目录，修改，提交</li><li><p>一般仓库中的文件可能存在于这三种状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Untracked files 文件未被跟踪　【处于工作区】</span><br><span class="line">2. Changes to be committed 文件已经被暂存，这是下次提交的内容　【处于暂存区】</span><br><span class="line">3. Changes but not updated 文件被修改，但没有添加到暂存区　【工作区】</span><br></pre></td></tr></table></figure></li><li><p>在开始新的路上，要把有变化的文件添加到索引库中，这个时候首先要遇见：git add命令</p><ol><li>git add -A [path]: 表示把path内的所有的tracked文件那些被修改／被删除／以及untrack的文件，添加到索引库中</li><li>git add -u [path]: 把path中所有的tracked文件，那些被修改／被删除的文件，添加到索引库中</li><li>git add -i [path]: 可以查看到path中所有被修改过／被删除但是还没有提交的文件</li><li>add兄弟家族还有好多，具体可以看看–help管家</li></ol></li><li><p>经历了add家族的接待，那些被添加到索引库的文件即将遇到另外一个兄弟：git commit命令，</p><ol><li>git commit -m “提交的描述信息”　：提交暂存区的文件</li><li>git commit -a -m “提交的描述信息”　：　提交暂存区以及工作区中已被tracked文件</li><li>git commit –amend “再次补充添加上次提交的描述信息”：补充提交信息</li></ol></li><li>经由commit的指引，我们来到了暂存区，这里都是即将要被push到老家的兄弟们：git push命令<ol><li>该命令用于将本地分支更新到暂存区的文件，推送到远程主机：</li><li>git push \&lt;远程主机&gt;　\&lt;本地分支&gt;:\&lt;远程分支名&gt; ; 一般常用 git push，其他更具体的用法请Ｇｏｏｇｌｅ</li><li>常见的一些情况：<ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.git push origin master :表示　将本地分支master推送到origin主机的master分支，如果不存在，则新建</span><br><span class="line">2.git push origin :master 表示　删除指定的远程分支master　</span><br><span class="line">    等同于推送一个空本地分支到远程分支</span><br><span class="line">    git push origin --delete master</span><br><span class="line">3.git push 推送当前分支到远程</span><br><span class="line">4.git push --all　推送所有本地分支到远程</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ul></li></ol><ol><li><p>天下大事，合久必分，分久必合。</p><ul><li><p>接下来git branch主要用法</p><ol><li>git branch 查看本地分支列表，当前分支“*”标示</li><li>git branch \<branchname>　创建分支，基于当前HEAD指向的提交</branchname></li><li>git branch \<branchname> \<start-point>　创建分支，基于指定的提交节点</start-point></branchname></li><li>git branch -d \<branchname> 　删除分支，弱删除（删除时检查索要删除的分支是否已经合并到其他分支中，否则拒绝）</branchname></li><li>git branch -D \<branchname>　强制删除</branchname></li><li>git branch -m \<oldbranch>　\<newbranch> 重命名分支，如果版本库中已经存在newbranch的分支，拒绝</newbranch></oldbranch></li><li>git branch -M \<oldbranch>　\<newbranch>　重命名分支，即使版本库中已经存在newbranch的分支，强制执行</newbranch></oldbranch></li></ol></li><li><p>那么git merge主要用法：把一个分支或某个commit的修改合并到现在的分支上</p><ol><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">usage: git merge [options] [&lt;commit&gt;...]</span><br><span class="line">   or: git merge [options] &lt;msg&gt; HEAD &lt;commit&gt;</span><br><span class="line">   or: git merge --abort</span><br></pre></td></tr></table></figure></li><li><p>先切换到目的分支：git checkout destination-branch</p></li><li>再将目标分支合并到目的分支：　git merge aim-branch</li><li>如果有冲突，先解决，再经过一次提交过程，完成合并</li></ol></li></ul></li></ol><ol><li>关于git的一些必要概念<ul><li>工作区：当前工程目录范围下</li><li>暂存区：即stage，一般存放在工程根目录下的.git/index文件夹，</li><li>版本库：工作区有一个隐藏目录.git　这个就是当前工程的版本库,是一个简单的数据库，其中包含所有用来维护与管理项目修订版本与历史信息。</li></ul></li></ol><p>##Git中rebase与merge的区别<br>    1. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git的常用命令&quot;&gt;&lt;a href=&quot;#git的常用命令&quot; class=&quot;headerlink&quot; title=&quot;git的常用命令&quot;&gt;&lt;/a&gt;git的常用命令&lt;/h1&gt;&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="工具类" scheme="http://wenchaos.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
      <category term="git" scheme="http://wenchaos.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>kotlin基本概念学习</title>
    <link href="http://wenchaos.com/android%E5%BC%80%E5%8F%91/kotlin%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://wenchaos.com/android开发/kotlin基本概念/</id>
    <published>2018-03-14T16:00:00.000Z</published>
    <updated>2019-07-28T07:55:17.652Z</updated>
    
    <content type="html"><![CDATA[<ol><li>协程<ol><li>对于耗时操作（网络io，文件io，cpu或gpu密集的操作），并且要求调用者等待，直到任务完成。协程提供了一种新的方式，可以避免线程阻塞，改为更加廉价可控的操作：协程</li><li>其他：<ol><li>JS的async/await </li><li>Go的channels，select</li><li>C#和python的generators和yield</li></ol></li><li>阻塞（Blocking）与挂起（Suspend）</li><li>简单的讲：协程就是一段计算过程；可以被挂起，但是不会阻塞线程（进程，线程的切换以及阻塞代价是昂贵的）；协程不会在某个随机的代码中挂起，只能在挂起点的地方挂起，即suspend挂起函数</li><li>挂起函数<ol><li>规则和普通函数一样；但是调用者只能是挂起函数，或者是协程，或者是协程或挂起函数中内联的函数字面值</li><li>挂起函数还可以是虚函数，即在接口中定义</li></ol></li><li>协程的内部工作机制 <ol><li>协程完全通过编译技术实现，（不需要VM或OS的特殊支持），挂起则是通过代码转换来实现。基本上，每个挂起函数，在编译期间都被转换为一个状态机，状态机中的各个状态对应于挂起调用。在挂起之前，状态机的下一个状态，以及相关的局部变量等信息，都会被保存到编译器生成的类的成员域变量中。协程恢复执行时，局部变量会被恢复出来，状态机会在挂起之后的状态继续执行。</li><li>协程挂起之后可以作为对象来保存和传递。，对象内部保存了协程的挂起后的状态，以及相关的局部变量等信息。这种对象的类型是Continuation，我们这里描述的整个代码转换过程，其实就是典型的“延续性传递编程风格”。因此挂起函数的底层实现技术会接受一个额外的Continuation的类型参数</li></ol></li><li>async/await/yield详细工作原理</li></ol></li><li>类型别名 typealias</li><li>与对象实例绑定的可调用的引用 <ol><li>操作符:: 用来得到一个成员的引用，指向一个具体的对象实例的方法或者属性</li></ol></li><li>封闭类（sealed class）与数据类（data class）<ol><li>Kotlin1.1中删除了1.0中对封闭类与数据类的一些限制。过去封闭类的子类只能声明在内部，现在可以声明在同一个module内任何一个地方；数据类可以继承其他类</li></ol></li><li>在lambda中使用解构声明</li><li>使用 _ 替代未使用的参数<ol><li>对于接受多个参数的lambda表达式，可以使用 _ 来代替你未使用到的参数</li><li>对于解构声明同样有效</li><li>在数字字面值中使用 _ 如val oneMillion = 1_000_000</li></ol></li><li>简洁的属性语法</li><li>委托属性：by lazy{ }<ol><li>局部的委托属性：可以用来定义一个延迟计算的局部变量（即 函数内部变量进行委托）</li><li>委托属性的拦截：操作符provideDelegate</li></ol></li><li>枚举值访问的通用方式</li><li>操作符<ol><li>onEach（）遍历集合与序列，对所有元素执行相同的操作，并返回iterator实例；与forEach类似</li><li>also（）：类似于apply（）：它得到一个接受者，然后对接受者执行某些操作，最后返回接受者；不同的是also内部是it指代，apply内部是this指代</li><li>takeIf（）类似于filter，但是前者适用于单只，并且满足条件，返回接受者，否则返回null；filter适用于集合序列；</li><li>takeUnless与takeIf相反</li><li>groupBy（）：用来对一个集合按照某个key进行分组，并同时合并所有的组。</li></ol></li><li>数组处理函数</li><li>常数内联 Constant inline：编译器现在可以将const val属性的值内联到这些属性被使用的地方</li><li>智能类型转换</li><li>允许将this::foo简写为::foo<ol><li>绑定到this的成员上的可调用的引用，可以不用明确的指定接受者</li></ol></li><li>基本语法：<ol><li>定义包 package import 目录结构可以与包结构不一致</li><li>函数定义 </li><li>变量定义：val只读（不可变） var读写（可变）<ol><li>属性与作用域</li></ol></li><li>注释</li><li>字符串模板 $</li><li>if else条件表达式，返回最后一行</li><li>when表达式</li><li>范围 in  !in </li><li>集合 val items = listOf(1,2,3)</li><li>数据类 data class Nmae（val name:String）<ol><li>所有属性的getter方法（var类型还有setter方法）</li><li>equals</li><li>hashCode</li><li>toString</li><li>copy</li></ol></li><li>函数参数的指定默认值</li><li>扩展函数</li><li>单例 object SingleObj{  }</li><li>如果不是null  ?.</li><li>如果不是null … else   ?.exp1 ?:   exp2</li><li>对同一个对象实例上调用多个方法  with（receiver）</li><li>代码规范：遵循java</li><li>扩展函数，中缀函数</li><li>范围函数：apply/with/run/also/let<ol><li>内部it：also，let</li><li>内部this</li><li>返回结果：上下文对象：apply，also</li><li>返回结果：某个值：with，let，run</li><li>来自链式调用 是否为null?.let/run/apply；否则with/also（receiver）{}</li></ol></li><li>基本类型<ol><li>数值类，Double Float Long Int Short Byte </li><li>支持进制 2 0b，10，16 0x</li></ol></li><li>相等性<ol><li>== 内容</li><li>=== 对象引用</li></ol></li><li>数组 Array <ol><li>创建方式 <ol><li>arrayOf</li><li>Array（size，lambda）</li></ol></li><li>ByteArray，ShortArray，IntArray 避免数值对象装箱带来的性能损耗 与Array不存在关系</li></ol></li><li>if when 表达式</li><li>do..while，while，for <ol><li>适用于iterator</li><li>return ： 默认行为是从最内层函数返回</li><li>break：结束最内层的循环</li><li>continue ：在最内层循环中，结束当前，跳转到下一次循环</li><li>@返回标签</li></ol></li><li>类与对象<ol><li>构造器 <ol><li>主/次  主构造器没有任何修饰时可省略关键字constructor</li><li>init{}初始化代码段</li><li>构造器中可以直接使用val var来声明对象的属性</li><li>如果类中有主构造器，则每个次级构造器必须委托给主构造器，要么直接委托，要么通过其他次级构造器间接委托 关键字this</li><li>init代码块实际上会 成为主构造器的一部分；会作为次级构造器的第一条语句执行</li></ol></li><li>包含内容<ol><li>构造器+init代码块</li><li>函数</li><li>属性</li><li>嵌套类，内部类</li><li>对象声明</li></ol></li><li>默认情况下kotlin中所有的类都是final的；关键字open显示指定，可以被继承</li><li>子类中有主构造器，则在主构造器中使用其参数来初始化基类</li><li>如果子类没有主构造器，则所有次级构造器都必须使用super关键字来初始化基类，或者间接委托</li><li>方法覆盖 open override final</li><li>属性覆盖：类似方法覆盖</li><li>初始化顺序：<ol><li>子类实例化构造过程中，首先需要初始化基类</li><li>。。</li></ol></li><li>覆盖的规则</li><li>抽象类与接口  <ol><li>默认open，可以有方法实现</li><li>抽象类可以存储状态数据，接口则不行，</li></ol></li><li>伴随对象：类似java静态方法</li></ol></li><li>可见度修饰符  <ol><li>public 默认</li><li>internal：module模块内</li><li>protected：同private，但是子类中可见</li><li>private：当前代码文件内，子类中不可见</li></ol></li><li>扩展<ol><li>扩展函数：    （静态）</li><li>扩展变量</li><li>意义：解决java中各种Utils不美观而且逐渐混乱的写法</li></ol></li><li>数据类</li><li>封闭类</li><li>泛型<ol><li>上界 ？extends E ：接受的参数类型是一个E类型，包括 E子类</li><li>生产者对应extends，消费者对应super</li><li>kotlin中，使用’声明处的类型变异’，确保只会生产T类型，关键字out（协变注解）</li><li>与out相反的是  ‘in’ 反向类型变异，只能用于消费者，如 Compareable</li><li>星号<em>投射， Function&lt;</em> ,String&gt;</li><li>泛型函数</li><li>泛型约束  即上界约束</li><li>类型擦除：kotlin只在编译器进行类型安全检查，泛型类型的实例不保存关于其类型参数的任何信息，比如Foo<int> 其类型信息会被擦除，只剩下Foo&lt;*&gt;</int></li></ol></li><li>嵌套类Nested class：类似于java的静态内部类<ol><li>class A{   class B{ }   }</li></ol></li><li>内部类Inner class  ：类似于java的内部类，持有外部类对象的一个引用<ol><li>class A{   inner class B{ }   }</li></ol></li><li>匿名内部类：类似于接口回调 可以使用lambda表示</li><li>枚举类 enum class Color{ RED，GREEN}<ol><li>每个枚举类常数都是一个对象，都是该枚举类的一个实例</li><li>也可以定义自己的匿名内部类</li></ol></li><li>对象表达式与对象声明<ol><li>有时我们需要在某个类基础上略作修改，但是又不希望重新声明一个新类，java中使用匿名内部类，kotlin中可以使用对象表达式或者对象声明</li><li>对象表达式：  <ol><li>setListenner(object : OnClickListener { } )</li><li>val person = object{ var name:String=“john”}</li><li>可以访问创建这个对象的代码范围内的变量</li></ol></li><li>注意：只有在局部并且私有的声明范围内，匿名对象才可以被用作类型。如果匿名对象作为公开函数的返回类型，或者公开属性的类型，那么这个函数或者属性的真实类型，会被     声明为这个匿名 对象的超类</li><li>对象声明： 不是一个表达式，因此不能出现在等式右边<ol><li>object Room{ }  </li><li>单例模式</li><li>对象声明中的初始化是线程安全的</li><li>伴随对象：<ol><li>在一个类的内部进行对象声明 关键字companion；</li><li>虽然伴随对象有些像java中类的静态成员，但是在运行期间，这些成员仍然是真是对象的实例的成员，它们与静态成员是不同的；举例来说就是，它们也可以实现接口</li><li>如果使用@JvmStatic注解，则可以让伴随对象在JVM上被编译为真正的静态方法和静态域</li></ol></li></ol></li><li>对象表达式与对象声明的不同：<ol><li>对象表达式，在使用处立即执行初始化</li><li>对象声明，是延迟初始化的，只会在首次访问到的时候进行初始化</li><li>伴随对象会在对应的类被装载解析时初始化，语义上等同于java中的静态初始化块</li></ol></li></ol></li><li>委托<ol><li>类的委托</li><li>属性的委托：有许多具有共性的属性，虽然可以在每个使用这些属性的类中手动实现它们，但是能够只实现一次，然后将它放在库中供所有需要的类使用，那将会好很多。比如<ol><li>延迟加载属性  by lazy：只有在初次访问时进行初始化，线程安全（如果不需要线程安全，则可以LayThreadSafetyMode.PUBLICATION，如果你确信初始化计算一定只发生在一个线程中，可以LayThreadSafetyMode.NONE来避免多余的线程同步带来的性能损耗）</li><li>可观察属性：observable ： 属性在发生变化时，可以向监听器发生通知<br> 1. </li><li>将多个属性保存在一个map中国馆过过过过，而不是将每个属性保存在一个独立的域</li></ol></li><li>为了解决这些以及其他问题，kotlin提供委托属性：<ol><li>语法：val/var propertyName : Type by  expr0 ；by后边是表达式，即委托属性的get、set方法将要被委托给这个expr0的对象的getValue 和setValue。</li></ol></li></ol></li><li>函数<ol><li>函数声明，函数参数，默认值，返回值，单表达式函数，不定数量参数varargs</li><li>中缀标记法 （关键字 infix 标记函数）<ol><li>优先级：infix 低于 算术运算符，类型转换，rangeTo；高于 布尔值运算符， &amp;&amp;， ||， is， in，</li></ol></li><li>函数范围：<ol><li>顶级函数，</li><li>类函数，</li><li>局部函数（函数中的函数），</li><li>扩展函数，</li><li>内联函数：<ol><li>关键字inline 标识函数</li><li>inline 既会影响到函数本身，也会影响到传递给它的lambda表达式：这两者都会被内联到调用处（因此会导致编译后代码体积增加，需要合理使用内联）</li><li>noinline标识不进行内联使用</li><li>内联属性：会将getter setter的内联到调用处</li><li>对Public API内联函数的限制：<ol><li>当一个内联函数为public 或 protected，则这个函数被认为是一个module的public api；其他module可以调用，并且被内联到调用处；此时可能会造成二进制代码不兼容的风险</li></ol></li></ol></li><li>高阶函数与lambda表达式<ol><li>定义：高阶函数是一种特殊的函数，它可以用函数当做入参，或者返回一个函数</li><li>lambda表现方式：<ol><li>Lambda表达式用大括号括起来 { }</li><li>参数（如果存在）定义在-&gt;之前，参数类型可以省略</li><li>（如果-&gt;存在）函数体定义在-&gt;之后</li><li>调用一个函数时，如果最后一个参数是函数类型，则可以用lambda表达式作为这函数参数的值</li><li>调用函数时，如果仅有一个唯一的函数类型的参数，则整个（）可以省略</li><li>使用下划线代替未使用到的参数</li></ol></li><li>匿名函数</li><li>闭包</li><li>带有接受者的函数字面值</li><li>缺点：高阶函数在运行时会带来一些不利：每个函数都是一个对象，而且它还要捕获一个闭包，也就是在函数体内部访问的那些外层变量。导致内存占用（函数对象和类都是会占用内存的）以及虚方法调用都会带来运行时的消耗；而很多情况下，编译器将lambda表达式内联在使用处，可以消除这些运行时消耗</li></ol></li><li>尾递归函数 （关键字 tailrec 标识函数 ）替代某些循环算法，同时不会存在栈溢出异常；编译器会对代码进行优化，消除函数的递归调用，产生一段基于循环实现的，快速且高效的代码；不能将尾递归用在try、catch结构中</li></ol></li></ol></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;协程&lt;ol&gt;
&lt;li&gt;对于耗时操作（网络io，文件io，cpu或gpu密集的操作），并且要求调用者等待，直到任务完成。协程提供了一种新的方式，可以避免线程阻塞，改为更加廉价可控的操作：协程&lt;/li&gt;
&lt;li&gt;其他：&lt;ol&gt;
&lt;li&gt;JS的async/await 
      
    
    </summary>
    
      <category term="笔记" scheme="http://wenchaos.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="kotlin" scheme="http://wenchaos.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>解决hexo搭建的博客中标签和分类页面没有内容</title>
    <link href="http://wenchaos.com/%E5%B7%A5%E5%85%B7%E7%AF%87/hexo%E4%B8%AD%E7%9A%84%E6%A0%87%E7%AD%BE%E5%92%8C%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2%E6%B2%A1%E6%9C%89%E5%86%85%E5%AE%B9/"/>
    <id>http://wenchaos.com/工具篇/hexo中的标签和分类页面没有内容/</id>
    <published>2017-12-26T16:00:00.000Z</published>
    <updated>2019-07-28T14:16:19.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在搭建hexo+github个人博客后，常常会遇到各种各样的问题。本文所涉及到的就是作者遇到的其中之一。那在网上查了诸多资料后，也一一尝试一遍，没有什么效果。不过根据那些解决方法，提供了一些思路。</p><h1 id="网上的解决方式"><a href="#网上的解决方式" class="headerlink" title="网上的解决方式"></a>网上的解决方式</h1><h3 id="生成tags和categories页面"><a href="#生成tags和categories页面" class="headerlink" title="生成tags和categories页面"></a>生成tags和categories页面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;tags&quot; //在source下的tags文件夹下生成index.md</span><br><span class="line">hexo new page &quot;categories&quot;  //在source下的categories文件夹下生成index.md</span><br><span class="line"># 注意：这里的两个页面其实是默认生成的，如果你检查了发现存在，则不必再生成一个</span><br></pre></td></tr></table></figure><h3 id="在对应的index-md中编辑内容"><a href="#在对应的index-md中编辑内容" class="headerlink" title="在对应的index.md中编辑内容"></a>在对应的index.md中编辑内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在/tags/index.md中添加</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">layout: &quot;tags&quot;</span><br><span class="line"></span><br><span class="line">在/categories/index.md添加</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br></pre></td></tr></table></figure><p>我这些都尝试了后，发现还是不行。然后突然发现一个热心群众提示到，<strong>需要将双引号去掉就行</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在/tags/index.md中添加</span><br><span class="line">type: tags</span><br><span class="line">layout: tags</span><br><span class="line"></span><br><span class="line">在/categories/index.md添加</span><br><span class="line">type: categories</span><br><span class="line">layout: categories</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在搭建hexo+github个人博客后，常常会遇到各种各样的问题。本文所涉及到的就是作者遇到的其中之一。那在网上查了诸多资料后，也一一尝试一
      
    
    </summary>
    
      <category term="工具篇" scheme="http://wenchaos.com/categories/%E5%B7%A5%E5%85%B7%E7%AF%87/"/>
    
    
      <category term="hexo" scheme="http://wenchaos.com/tags/hexo/"/>
    
  </entry>
  
</feed>
