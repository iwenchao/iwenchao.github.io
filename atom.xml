<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大王派我来巡山</title>
  
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wenchaos.com/"/>
  <updated>2019-07-27T02:21:40.035Z</updated>
  <id>http://wenchaos.com/</id>
  
  <author>
    <name>wenchaos</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>android中侧边栏的使用剖析</title>
    <link href="http://wenchaos.com/android%E5%BC%80%E5%8F%91/android%E4%B8%AD%E4%BE%A7%E8%BE%B9%E6%A0%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%89%96%E6%9E%90/"/>
    <id>http://wenchaos.com/android开发/android中侧边栏的使用剖析/</id>
    <published>2019-03-04T16:00:00.000Z</published>
    <updated>2019-07-27T02:21:40.035Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="笔记" scheme="http://wenchaos.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="android" scheme="http://wenchaos.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android接入ffmpeg的介绍</title>
    <link href="http://wenchaos.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/android%E6%8E%A5%E5%85%A5ffmpeg%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <id>http://wenchaos.com/音视频基础/android接入ffmpeg的介绍/</id>
    <published>2018-10-08T16:00:00.000Z</published>
    <updated>2019-07-28T07:54:07.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h3><ol><li>JNI</li><li>CPU架构</li><li>交叉编译</li><li>NDK</li><li>ffmpeg相关</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h3 id=&quot;必备知识&quot;&gt;&lt;a href=&quot;#必备知识&quot; class=&quot;headerlink&quot; title=&quot;必备知识&quot;&gt;&lt;/a&gt;必备知识&lt;/h
      
    
    </summary>
    
      <category term="android，ffmpeg" scheme="http://wenchaos.com/categories/android%EF%BC%8Cffmpeg/"/>
    
    
      <category term="音视频" scheme="http://wenchaos.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>ffmepg中的日志操作</title>
    <link href="http://wenchaos.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/FFmpeg/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    <id>http://wenchaos.com/音视频基础/FFmpeg/日志系统/</id>
    <published>2018-08-16T16:00:00.000Z</published>
    <updated>2019-07-28T07:53:33.192Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="ffmpeg" scheme="http://wenchaos.com/categories/ffmpeg/"/>
    
    
      <category term="ffmpeg" scheme="http://wenchaos.com/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>java后端搭建初稿</title>
    <link href="http://wenchaos.com/java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%90%8E%E7%AB%AF%E6%90%AD%E5%BB%BA%E5%88%9D%E7%A8%BF/"/>
    <id>http://wenchaos.com/java后端开发/java后端搭建初稿/</id>
    <published>2018-06-08T16:00:00.000Z</published>
    <updated>2019-07-28T07:55:25.082Z</updated>
    
    <content type="html"><![CDATA[<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ol><li>java基础知识</li><li>Servlet与jsp基础知识</li><li>Spring+SpringMVC+Mybatis使用</li><li>Redis使用</li></ol><h3 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h3><ol><li>intellij idea：ide</li><li>tomcat或者jetty：server容器</li><li>Navicat premiun:管理数据库</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;java基础知识&lt;/li&gt;
&lt;li&gt;Servlet与jsp基础知识&lt;/li&gt;
&lt;li&gt;Spring+Spring
      
    
    </summary>
    
      <category term="后端开发" scheme="http://wenchaos.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java，后端开发" scheme="http://wenchaos.com/tags/java%EF%BC%8C%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>c++是一门值得学习的语言呢</title>
    <link href="http://wenchaos.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c++%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://wenchaos.com/编程语言/c++语言入门总结/</id>
    <published>2018-05-08T16:00:00.000Z</published>
    <updated>2019-07-14T09:21:14.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文内容主要来自《C++ Primer Plus》</p><h1 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h1><h2 id="第一章摘要"><a href="#第一章摘要" class="headerlink" title="第一章摘要"></a>第一章摘要</h2><ol><li>面向过程与面向对象</li><li>几种c++编译器的使用方法</li></ol><h2 id="第二章摘要（无）"><a href="#第二章摘要（无）" class="headerlink" title="第二章摘要（无）"></a>第二章摘要（无）</h2><h2 id="第三章摘要"><a href="#第三章摘要" class="headerlink" title="第三章摘要"></a>第三章摘要</h2><ol><li>数据类型</li><li>数据类型之间的转换</li></ol><h2 id="第四章摘要"><a href="#第四章摘要" class="headerlink" title="第四章摘要"></a>第四章摘要</h2><ol><li>复合类型<ol><li>数组</li><li>结构</li><li>指针</li></ol></li><li>内存分配的一些方法</li></ol><h2 id="第五章摘要"><a href="#第五章摘要" class="headerlink" title="第五章摘要"></a>第五章摘要</h2><ol><li>循环 <ol><li>for</li><li>while</li><li>do while</li></ol></li><li>关系表达式</li></ol><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><ol><li>分支语句<ol><li>if else </li><li>switch</li></ol></li><li>逻辑运算符</li></ol><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><ol><li>函数<ol><li>c++和c函数的共同特性</li><li>函数定义</li><li>函数原型</li></ol></li><li>函数指针</li></ol><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><ol><li>c++中函数的新增特性<ol><li>内联函数</li></ol></li></ol><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><ol><li>内存模型</li><li>名称空间</li></ol><h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><ol><li>对象和类</li></ol><h2 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h2><ol><li>运算重载符</li></ol><h1 id="重点部分"><a href="#重点部分" class="headerlink" title="重点部分"></a>重点部分</h1><ol><li>类和对象</li><li>继承</li><li>多态，虚函数和RTTI（运行时类型识别）</li><li>函数重载</li><li>引用变量</li><li>泛型（独立于类型的）编程</li><li>处理错误的异常机制</li><li>管理函数，类和变量名的名称空间</li></ol><h1 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文内容主要来自《C++ Primer Plus》&lt;/p&gt;
&lt;h1 id=&quot;基础部分&quot;&gt;&lt;a href=&quot;#基础部分&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="c++" scheme="http://wenchaos.com/categories/c/"/>
    
    
      <category term="编程语言" scheme="http://wenchaos.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>同步与异步</title>
    <link href="http://wenchaos.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
    <id>http://wenchaos.com/计算机基础/同步与异步/</id>
    <published>2018-04-15T16:00:00.000Z</published>
    <updated>2019-07-28T07:54:46.703Z</updated>
    
    <content type="html"><![CDATA[<p>在讲到同步，异步，并发，并行，阻塞与非阻塞这些概念的时候，一定会涉及到进程与线程的相关概念。因此需要先了解一下进程与线程。</p><p>#进程与线程</p><ol><li>进程（Process）：具有独立功能的程序在某个数据集合上的一次运行活动；是OS进行资源分配和保护的基本单位。</li><li>线程（Thread）：</li><li>区别：<ol><li>进程是系统资源分配的基本单位，线程是cpu调度，程序执行的最小单位。</li><li>进程有独立的地址空间，而同一进程中的线程共享改进程的地址空间。</li><li>线程间通信</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在讲到同步，异步，并发，并行，阻塞与非阻塞这些概念的时候，一定会涉及到进程与线程的相关概念。因此需要先了解一下进程与线程。&lt;/p&gt;
&lt;p&gt;#进程与线程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程（Process）：具有独立功能的程序在某个数据集合上的一次运行活动；是OS进行资源分配和保
      
    
    </summary>
    
      <category term="java" scheme="http://wenchaos.com/categories/java/"/>
    
    
      <category term="并发" scheme="http://wenchaos.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github搭建个人博客攻略</title>
    <link href="http://wenchaos.com/%E5%B7%A5%E5%85%B7%E7%AF%87/hexo+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%94%BB%E7%95%A5/"/>
    <id>http://wenchaos.com/工具篇/hexo+github搭建博客攻略/</id>
    <published>2018-04-09T16:00:00.000Z</published>
    <updated>2019-05-06T15:24:04.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>随着国内开发者水平的提高，以及各个技术博客的平台相继出现。有些人更愿意将写的博客记录在自己的平台上，故而引出本文。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;随着国内开发者水平的提高，以及各个技术博客的平台相继出现。有些人更愿意将写的博客记录在自己的平台上，故而引出本文。&lt;/p&gt;

      
    
    </summary>
    
      <category term="工具，" scheme="http://wenchaos.com/categories/%E5%B7%A5%E5%85%B7%EF%BC%8C/"/>
    
    
      <category term="工具，hexo，github" scheme="http://wenchaos.com/tags/%E5%B7%A5%E5%85%B7%EF%BC%8Chexo%EF%BC%8Cgithub/"/>
    
  </entry>
  
  <entry>
    <title>c是一门值得学习的语言呢</title>
    <link href="http://wenchaos.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://wenchaos.com/编程语言/c语言入门总结/</id>
    <published>2018-04-08T16:00:00.000Z</published>
    <updated>2019-07-13T09:55:28.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="3。数据类型"><a href="#3。数据类型" class="headerlink" title="3。数据类型"></a>3。数据类型</h1><ol><li>2.<br>3.</li><li><p>实型数据（又称浮点类型）</p><ul><li>实型常量的表示方法<ol><li>小数形式</li><li>指数形式</li></ol></li><li>实型变量<ol><li>在内存中的存放形式<ul><li>一般占4个字节byte（32位）</li></ul></li><li>实型变量的分类<ol><li>单精度float：4个字节</li><li>双精度double：8个字节</li><li>长双精度long double: </li></ol></li></ol></li></ul></li><li><p>结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct st&#123;</span><br><span class="line">    int a;//成员a</span><br><span class="line">    int b;//成员b</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>枚举</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum em&#123;</span><br><span class="line">    red=0,</span><br><span class="line">    green,</span><br><span class="line">    black</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>文件操作</p><ol><li>文件类型 FILE* file</li><li>打开文件 FILE* fopen(path,mode)</li><li>fwrite/fread</li><li>fclose</li><li>文件游标操作 rewind</li></ol></li><li><p>指针</p><ol><li>它就是变量在内存中的一个地址；</li><li>指针本身的运算；</li><li>指针所指的内容的运算；</li></ol></li></ol><ol><li><p>操作系统如何管理内存；</p><ol><li>内核空间</li><li>栈控件；</li><li>引用库</li><li>堆空间</li><li>内存映射</li><li><p>内存的分配与释放；</p><ol><li>分配： void* mem = malloc(size);</li><li>释放：free(mem);</li></ol></li><li><p>内存泄漏与野指针</p><ol><li>不断的向系统申请内存；</li><li>申请内存不用，也不释放；</li><li>占用别人的内存成为野指针；</li></ol></li></ol></li><li><p>函数指针</p><ol><li>返回值类型 (* 指针变量名)([形参列表])<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int func(int x)函数</span><br><span class="line">int （*f）(int x);</span><br><span class="line">f =func;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>编译器；</p><ol><li>gcc：linux下的编译器</li><li>clang：mac下使用的编译器</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gcc/clang -g -O2 -o test test.c -I</span><br><span class="line">注释：</span><br><span class="line">1. -g:输出文件中的调试信息；</span><br><span class="line">2. -O：对输出文件做指令优化；</span><br><span class="line">3. -o：输出文件</span><br><span class="line">4. -I：指定头文件；</span><br><span class="line">5. -L：指定三方库文件位置；</span><br><span class="line">6. -l:指定使用哪个库</span><br></pre></td></tr></table></figure></li><li><p>编译过程：</p><ol><li>预编译：#\&lt;include>，将引用到文件，头文件加载</li><li>编译</li><li>链接：将系统库和三方库 与编译好的项目代码进行合并<ol><li>动态链接：代码执行中进行链接</li><li>静态链接: </li></ol></li></ol></li></ol></li><li><p>调试器</p><ol><li>gdb：</li><li>lldb：</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h1 id=&quot;3。数据类型&quot;&gt;&lt;a href=&quot;#3。数据类型&quot; class=&quot;headerlink&quot; title=&quot;3。数据类型&quot;&gt;&lt;/a&gt;3
      
    
    </summary>
    
      <category term="java" scheme="http://wenchaos.com/categories/java/"/>
    
    
      <category term="并发" scheme="http://wenchaos.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频入门基础</title>
    <link href="http://wenchaos.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/"/>
    <id>http://wenchaos.com/音视频基础/音视频入门基础/</id>
    <published>2018-04-08T16:00:00.000Z</published>
    <updated>2019-06-12T13:57:54.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><h2 id="1-1音视频知识"><a href="#1-1音视频知识" class="headerlink" title="1.1音视频知识"></a>1.1音视频知识</h2><ol><li>音视频采集</li><li>音视频硬软编解码</li><li>FFmpeg</li><li>WebRTC</li><li>音视频处理架构</li><li>网络传输</li></ol><h1 id="2-音频入门基础"><a href="#2-音频入门基础" class="headerlink" title="2.音频入门基础"></a>2.音频入门基础</h1><h1 id="3-视频入门基础"><a href="#3-视频入门基础" class="headerlink" title="3.视频入门基础"></a>3.视频入门基础</h1><ol><li>视频基本知识</li><li>H264宏块的划分与帧分组</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h1&gt;&lt;h2 id=&quot;1-1音视频知识&quot;&gt;&lt;a href=&quot;#1-1音视频知识&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
      <category term="java" scheme="http://wenchaos.com/categories/java/"/>
    
    
      <category term="并发" scheme="http://wenchaos.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ffmepg中的文件操作</title>
    <link href="http://wenchaos.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/FFmpeg/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://wenchaos.com/音视频基础/FFmpeg/文件操作/</id>
    <published>2018-04-08T16:00:00.000Z</published>
    <updated>2019-07-13T10:12:31.862Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>文件创建和删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;libavformat/&gt;avformat.h&gt;</span><br><span class="line">#include &lt;libavutil/log.h&gt;</span><br><span class="line"></span><br><span class="line">//删除文件</span><br><span class="line">int ret = avpriv_io_delete(filepath);</span><br><span class="line">   </span><br><span class="line">// 重命名文件</span><br><span class="line">avpriv_io_move(sourcefilename,targetfilename);</span><br><span class="line"></span><br><span class="line">//操作目录</span><br><span class="line">avio_open_dir();</span><br><span class="line">//</span><br><span class="line">avio_read_dir();</span><br><span class="line">//</span><br><span class="line">avio_close_dir();</span><br><span class="line">//</span><br><span class="line">avio_free_directory_entry();</span><br></pre></td></tr></table></figure></li><li><p>重要结构体</p><ol><li>AVIODirContext:操作目录的上下文；</li><li>AVIODirEntry: 目录项。 用于存放文件名，文件大小信息</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;文件创建和删除&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
      <category term="ffmpeg" scheme="http://wenchaos.com/categories/ffmpeg/"/>
    
    
      <category term="ffmpeg" scheme="http://wenchaos.com/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>http的一路历程</title>
    <link href="http://wenchaos.com/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/http%E7%9A%84%E4%B8%80%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    <id>http://wenchaos.com/网络基础/http的一路历程/</id>
    <published>2018-04-04T16:00:00.000Z</published>
    <updated>2019-07-28T01:57:18.619Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP诞生于1991年，是互联网领域一个基石性的协议。全世界电脑上的内容能互联起来，全拜HTTP所赐。因此好好的学习了解一下是必不可少的。</p><h1 id="TCP-IP的分层管理"><a href="#TCP-IP的分层管理" class="headerlink" title="TCP/IP的分层管理"></a>TCP/IP的分层管理</h1><pre><code>这里呢其实有两种分层的方式，一种是</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HTTP诞生于1991年，是互联网领域一个基石性的协议。全世界电脑上的内容能互联起来，全拜HTTP所赐。因此好好的学习了解一下是必不可少的。&lt;/p&gt;
&lt;h1 id=&quot;TCP-IP的分层管理&quot;&gt;&lt;a href=&quot;#TCP-IP的分层管理&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="网络" scheme="http://wenchaos.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="http" scheme="http://wenchaos.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Android开发需要知道gradle的常用知识</title>
    <link href="http://wenchaos.com/android%E5%BC%80%E5%8F%91/Android%E5%BC%80%E5%8F%91%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93gradle%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86/"/>
    <id>http://wenchaos.com/android开发/Android开发需要知道gradle的常用知识/</id>
    <published>2018-03-27T16:00:00.000Z</published>
    <updated>2018-04-21T08:04:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>#</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#&lt;/p&gt;

      
    
    </summary>
    
      <category term="工具类" scheme="http://wenchaos.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
      <category term="gradle" scheme="http://wenchaos.com/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Java的常用知识整理</title>
    <link href="http://wenchaos.com/java%E5%9F%BA%E7%A1%80%E7%AF%87/java%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>http://wenchaos.com/java基础篇/java的常用知识整理/</id>
    <published>2018-03-27T16:00:00.000Z</published>
    <updated>2019-07-28T07:55:34.213Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Java主要方面<ol><li>面向对象的特性</li><li>集合（特点，数据结构（数组，栈，队列，双向队列，红黑树，二叉树等））</li><li>JVM虚拟机（加载机制/内存以及垃圾回收）</li><li>线程与进程，异步</li><li>注解/反射/泛型</li><li>设计模式（单例，建造者，适配器，工厂，策略，观察者，代理）</li><li>算法（数据结构/排序，查找等）</li></ol></li><li>面向对象的特征<ol><li>抽象：针对某一类对象的共同特征总结出来构造类的过程，抽象只关注对象有哪些共同的属性和行为，而不关心具体内容<ol><li>数据抽象</li><li>行为抽象</li></ol></li><li>继承：从已有类得到继承信息创建新类的过程。</li><li>封装：通常认为封装是把数据和行为绑定起来，对数据的访问只能通过定义的接口。封装就是隐藏一切可以隐藏的东西，只向外界提供最简单的编程接口。</li><li>多态性：指的是允许不同子类型的对象对同一消息作出不同的行为。即同样的对象引用调用同样的方法，但是做了不同的事情。<ol><li>编译时多态：方法重载（前期绑定），同一个类中，同名方法不同参；对返回值没有要求</li><li>运行时多态：方法重写（后期绑定），<ol><li>父子类中，即 子类继承父类已有的或者抽象的方法；</li><li>返回类型相同，</li><li>修饰符权限更开放，</li><li>不能比父类声明更多的异常（里氏替换原则）</li><li>方法重写，2. 对象造型（向下）即：用父类型引用 引用子类型对象实例，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为</li></ol></li><li>多态性的作用：<ol><li>封装：可以隐藏实现细节，便于模块化；继承可以扩展已存在的类；封装和继承都是为了代码重用性，而多态则是为了实现—接口重用！真正具有价值的重用就是“接口重用”，因为接口设计比实现接口更费时间，更花费工程师的精力。</li></ol></li></ol></li><li>问题：<ol><li>问题：从JVM/深一层的角度具体描述一下实现的机制？？？</li><li>继承与组合的不同</li></ol></li></ol></li><li>访问修饰符的区别<ol><li>public：对所有类公开，不论是不是同一包下</li><li>protect ：仅仅对同包下子类公开</li><li>default：默认对于同一个包下的其他类相当于public，非同一个包下的相当于private</li><li>private：仅仅当前类中可以访问到</li></ol></li><li>java面试题180 <ol><li>（上） <a href="http://blog.csdn.net/jackfrued/article/details/44921941" target="_blank" rel="noopener">http://blog.csdn.net/jackfrued/article/details/44921941</a>  例：</li><li>String是基本类型吗？答：不是，基本类型有八种：byte ,short , int , long , double , float , char , boolean; 其他的都是引用类型，Java5引入的枚举enum也属于引用类型</li></ol></li><li>解释内存中的栈（stack）堆（heap）和方法区（method area）<ol><li>栈空间：通常基本数据类型，对象的引用，以及函数调用的现场保存 </li><li>堆空间：通过new或者构造器创建的对象 （垃圾回收的主要区域，因为垃圾回收器大多数采用分代收集算法，所以堆空间还细分了 新生代，老生代）</li><li>方法区：</li><li>方法区和堆空间都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息，常量，静态变量，JIT编译器编译后的代码等数据；</li><li>程序中的字面量，如100，“Hello”和常量都是放在常量池中，常量池是方法区的一部分</li><li>栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数进行调整</li><li>栈空间用光了会引发StackOverflowError，而堆空间和常量池不足则会引发OutOfMemoryError</li><li>例子：String str = new String（“Hello”）中，变量str，作为引用，放在栈中；new创建的字符串对象放在堆上，而“Hello”这个字面量放在方法区</li><li>补充：<ol><li>Java6 开始，由于JIT编译器的发展和“逃逸技术”逐渐成熟，栈上分配，标量替换等优化技术使得对象不一定非得分配在堆中；</li><li>运行时常量池相当于Class文件常量池具有动态性，Java语言并不要求常量一定只有编译器才能产生，运行期也可以将新的常量放入池中，String的intern()方法就是这样；</li></ol></li></ol></li><li>switch能否作用在byte，long上？String呢；（为什么？？？）<ol><li>答：Java 5 以前只能是byte ，short，char，int ；java 5 开始引入enum；Java 7 开始引入String；而long不可以；</li></ol></li><li>两个对象值相同（x.equals(y) == true），但却可以有不同的hash code吗？<ol><li>答：不对；Java对于equals方法和hashcode方法是这样规定：</li><li>如果两个对象相同（x.equals(y) == true），那么他们的hashCode值一定要相同；</li><li>如果两个对象hashCode相同，他们不一定相同；</li><li>补充：如果违背了java的这种规则，就会发现：在使用容器时，相同的对象可以set集合中出现，同时增加新元素的效率大大下降（这是因为使用哈希存储的系统，如果哈希码频繁的冲突，将会造成存取性能的急剧下降）</li><li>补充：equals方法必须满足：自反性，对称性，传递性，一致性</li><li>补充：重写equals方法的优秀要求：<ol><li><ol><li>使用==操作符检查”参数是否为这个对象的引用”；</li></ol></li><li><ol><li>使用instanceof操作符检查”参数是否为正确的类型”；</li></ol></li><li><ol><li>对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；</li></ol></li><li><ol><li>编写完equals方法后，问自己它是否满足对称性、传递性、一致性；</li></ol></li><li><ol><li>重写equals时总是要重写hashCode；</li></ol></li><li><ol><li>不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。  </li></ol></li></ol></li></ol></li><li>String和StringBuilder StringBuffer的区别<ol><li>String：不可变，只读</li><li>StringBuilder：可修改，Java 5引入，单线程，因为没有被做线程安全的处理，所以效率比StringBuffer高</li><li>StringBuffer：可修改，多线程安全，效率相对低</li><li>补充：什么情况下用 +运算符进行字符串连接，比用StringBuffer和StringBuilder性能好；<ol><li>+运算符的操作本质是创建了StringBuilder对象进行append操作，然后将结果toString</li></ol></li></ol></li><li>描述一下JVM加载class文件的原理机制<ol><li>JVM中类的装载是由类加载器（classLoader）和他的子类来实现的；是java运行时系统的一个重要组件，负责在运行时查找和装入类文件</li><li>由于java的跨平台型，经过编译的java源程序并不是一个可执行程序，而是一个或多个中间文件。</li><li>当java程序需要某个文件时，JVM会确保这个类已经被加载–&gt;链接（验证—&gt; 准备—&gt;解析）—&gt;初始化。类的加载是指把类的.class文件读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。</li><li>加载完成后，Class对象还不完整，还不可用。被加载后，进入连接过程，包括验证，，准备（为静态变量分配内存，设置初始值）和解析（将符号引用替换成直接引用）。</li><li>最后JVM对类进行初始化。如果该类存在直接的父类并且这个父类也还没有被初始化，则先初始化父类；如果该类中存在初始化语句，就依次执行这些初始化语句</li><li>类加载器：<ol><li>根加载器：Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）（不是java语言所编写的）</li><li>扩展加载器：Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；</li><li>系统加载器：System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</li><li>用户自定义加载器：</li><li>加载流程：应用启动：JVM启动—&gt;bootstrap classloader运行，加载java运行的核心类库，同时加载扩展加载器和系统加载器；—&gt;扩展加载器去加载扩展Api，—&gt;app classloader 加载CLASSPATH 目录下定义的class，通常没有特别指定的情况下，程序自定义类文件有系统加载器加载。</li></ol></li><li>双亲委托模式：<ol><li>优先判断父类加载器是否已经加载class文件，如果没有则子类进行；若parent classloader为null ，则调用 bootstrap classloader进行加载</li><li>优缺点：<ol><li>避免重复加载</li><li>安全问题：如果不适用这个模式，则有可能造成外来类替换java核心类的安全隐患</li></ol></li><li>流程：<ol><li>入口在ClassLoader.loadClass(name,boolean resolve):类名称，是否需要解析类；在执行类之前，需要考虑是否需要解析类，并不总是需要解析，如果JVM只需要知道该类是否存在或找出该类的超类，则不需要解析</li><li>defineClass<ol><li>接受由原始字节组成的数组，并将之转成Class对象。原始数组包含从文件系统或者网络装入的数据。defineClass管理JVM的许多复杂实现，它把字节码分析成运行时数据结构，校验有效性等。该方法为finla，不可重写</li></ol></li><li>findSystemClass方法<ol><li>从本地文件系统装入</li></ol></li></ol></li></ol></li><li>Class.forName 与classloader加载的类文件有什么区别<ol><li>loadClass加载 类实际上是在加载的时候并不对该类进行解析，因此不会初始化该类；而Class.forName则想反，在forName加载的时候就会将Class进行解析以及初始化！</li></ol></li></ol></li><li>抽象类与接口的区别：<ol><li>相同点：<ol><li>不能被实例化</li><li>可以定义抽象类和接口类型的引用</li></ol></li><li>不同点：<ol><li>抽象类：可以有构造器；可以有抽象方法，具体方法；不一定有抽象方法；可以有private、默认、protected、public的成员变量</li><li>接口：没有构造器；只能有抽象方法；只能是常量 public static final ；没有静态方法</li><li>在继承体系中，抽象类继承是属于is-a的关系；接口的实现属于has-a的关系</li></ol></li><li>语法层面上的区别<ol><li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的</li><li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ol></li><li>设计层面上的区别<ol><li>抽象层次不同：抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象</li><li>跨域不同，抽象类作为很多子类的父类，它是一种具有相似特点的类。而接口是一种行为规范，它可以跨多种域，它是一种辐射式设计</li><li>设计层次不同：对于抽象类，它是自子类而父类来设计（自下而上），先知道子类才能抽象出父类，而接口不同，接口只是定义一种行为，不管行为的具体实施。</li></ol></li></ol></li><li>集合部分<ol><li>Collection：Java不提供直接继承Collection<ol><li>List：有序，索引，可重复<ol><li>ArrayList：<ol><li>允许所有元素，包括null</li><li>不是线程安全</li></ol></li><li>LinkedList：<ol><li>允许null元素，</li><li>常常被用作stack，queue，deque（双向队列）</li><li>不是线程安全！一种解决方法是在创建List时构造一个同步的List：List list = Collections.synchronizedList(new LinkedList(…));</li></ol></li><li>Vector：线程安全！非常类似ArrayList<ol><li>Stack：实现一个后进先出的堆栈；push，pop，peak，empty，search</li></ol></li></ol></li><li>Set：无重复<ol><li>HashSet</li><li>TreeSet</li><li>LinkedHashSet</li></ol></li><li>Queue<ol><li>PriorityQueue</li></ol></li><li>Collection类型的集合都支持iterator()方法，该方法返回一个Iterator it = collection.iterator(); // 获得一个迭代子</li></ol></li><li>Map：内部一个K-V映射的哈希表，由于作为key的对象将通过计算其散列值来确定与之对应的value的位置，因此任何作为key的对象必须实现hashCode，equals方法<ol><li>HashMap：键值对允许null，</li><li>HashTable：键值对非null，同步的</li><li>WeakHashMap：</li><li>TreeMap与TreeSet：<ol><li>TreeMap继承Map，TreeSet继承Set，TreeSet底层是通过TreeMap来实现的（如同HashSet底层是通过HashMap还实现的）</li><li>TreeMap的实现就是红黑树算法</li><li>相同点：<ol><li>都是有序集合，存储的值都是排好序的；</li><li>都是非同步集合，不能在多线程环境中使用，（可以使用Collections.synchronizedMap()进行同步化）</li><li>运行速度都要比hash集合慢，内部对元素的操作 时间复杂度为O(logN)，而HashMap/HashSet则为O(1)。因为一个是树结构，一个数组结构</li></ol></li><li>不同点：<ol><li>主要区别是实现接口不一样；</li><li></li></ol></li></ol></li></ol></li><li>涉及到堆栈，队列：list</li></ol></li><li>同步异步<ol><li>Synchronized，volatile，</li><li>java.util.concurrent.locks.Lock</li><li>Semaphore信号量</li><li>FutureTask：<ol><li>类似Runnable，都可以通过Thread来启动；不同的是FutureTask可以返回执行完毕后的数据，并且get（）是阻塞的；</li><li>可用于进行资源的预处理/预加载</li></ol></li><li>CyclicBarrier：可以阻塞一组线程，当同时满足条件后，才能解除阻塞继续执行下面的操作；单个线程中调用await（）并不管用；</li><li>Executor：线程池</li><li>Timer：定时器（偏向于单个任务）<ol><li>缺陷<ol><li>对于多个任务，timer内部只有一个任务线程，所以某个任务执行时间过长，导致不能按照我们定时器预定的执行；可以用ScheduledThreadPool弥补</li><li>一旦TimerTask出现了异常，Timer会停止所有任务的运行</li></ol></li></ol></li></ol></li><li>序列化以及意义：<ol><li>用来处理对象流的一种机制，所谓对象流也就是将对象的内容进行流化，可以对流化后的对象进行读写操作，或者传输于网络之间。序列化是为了解决对象流读写操作过程中可能引发的数据乱序问题。</li><li>实现序列化需要实现Serializable接口，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆（可以参考第29题）。</li></ol></li><li>final，finally ，finalize的区别<ol><li>final 用于控制成员变量，方法，或者是一个类是否可以被覆写或继承等功能；<ol><li>成员：<ol><li>一旦初始化后，不可改变；基础类型变量：值不改变，引用类型变量：引用不可改变（其初始化的地方在 声明处或者构造器中）</li><li>对于方法参数中final，基础类型的参数没有什么实际意义；但是对于引用类型的参数，因为其传递的是对象的引用，这样你在方法中对对象变量的修改也会影响到调用语句中对象变量。当方法中不需要改变作为参数的这个对象变量时，声明为final，防止你无意中修改到它而影响到方法的调用处。</li></ol></li><li>方法：<ol><li>不能重写，但是子类可以继承</li><li>允许编译器将所有对此方法的调用转化成inline（行内）调用的机制，它会在调用方法时，直接将方法主体插入到调用处，而不是进行例行的方法调用。提高了程序效率，但是当方法主体很大的时候，反而使得插入地方迅速膨胀，反而影响了效率。</li></ol></li><li>类：<ol><li>不可被继承；其中的方法也是默认为final</li></ol></li></ol></li><li>finally：对捕获异常模型的补充，finally块始终会最后执行。finally块中的return语句会覆盖之前的return结果</li><li>finalize：根据Java语言规范，JVM保证调用finalize函数之前，这个对象是不可达的，而且JVM不保证一定会调用该方法</li></ol></li><li>传递与引用<ol><li>首先可以确定的说：Java传递的是值的副本<ol><li>基本类型变量：传递的是变量值的副本；也就是说即使副本被改变，原始变量值不会变</li><li>对象类型变量：传递的是引用的副本；因为传递的是引用，则引用内容可能会改变；</li></ol></li></ol></li><li>算法复杂度的计算：<ol><li>时间复杂度</li><li>空间复杂福</li></ol></li><li>JVM详解<ol><li>Java引用的四种状态<ol><li>强引用：new出来的对象，处于堆内存中，指向它的引用在栈中（内存空间不足，也不回收）</li><li>软引用：（内存空间足，不回收；不足，可能会随时被回收）常用来实现内存敏感的高速缓存</li><li>弱引用：每次Gc时，一旦发现有弱引用对象，不管内存是否足，都会回收</li><li>虚引用：类似于没有任何引用一样，在任何时候都可能会被回收；主要用于跟踪对象呗垃圾回收器回收的活动</li></ol></li><li>Java中内存的划分<ol><li>程序计数器：保证线程切换后能恢复到原来的执行位置 （线程私有）</li><li>jvm虚拟机栈：栈内存，为java方法服务，方法为调用 创建栈帧—&gt;局部变量表—&gt;局部变量，对象的引用，动态链接，方法出口灯（线程私有）（StackOverFlowError、OutOfMemoryError）</li><li>本地方法栈：为虚拟机运行使用到的Native方法服务（线程私有）（StackOverFlowError、OutOfMemoryError）</li><li>堆内存：存放所有new出来的对象（线程共享）（OutOfMemoryError）</li><li>方法区：存储被虚拟机JVM加载进来的类信息，常量，静态常量，静态方法等；（线程共享）</li><li>字符串常量池：方法区的一部分（线程共享）（OutOfMemoryError），一个由数组组成的表constant_pool[]用于存放Class，String以及基本类型的数据</li><li>补充：1，2，3这三个内存区域伴随线程，不需要考虑回收，线程结束，该区域自动会被回收；堆、方法区是Gc的主要战场，这里的内存分配是动态的</li><li>例子：String str = new String（“abc”）；创建了2个对象，一个在编译期创建“abc”，一个在运行期由new创建</li></ol></li><li>对象在内存中的状态<ol><li>可到达：自创建后，被一个或多个变量引用，则可达；从根节点上可触及到这个对象（引用链）</li><li>可恢复：对象不再被任何变量引用就进入了可恢复状态，回收该对象之前，会先调用finalize()方法，如果有重新有变量引用，则可达；</li><li>不可达：　Java对象不被任何变量引用，且系统在调用对象的finalize()方法后依然没有使该对象变成可达状态（该对象依然没有被变量引用），那么该对象将变成不可达状态。当Java对象处于不可达状态时，系统才会真正回收该对象所占有的资源。</li></ol></li><li>判断对象死亡的两种常用算法<ol><li>引用计数法：给对象增加一个引用计数器，0&lt;，则有引用；0&gt;，则无变量引用<ol><li>优点：算法简单，判断效率高</li><li>缺点：很难解决对象之间相互循环引用的问题</li></ol></li><li>根搜索算法：（当前采用）<ol><li>设立若干种root对象，当任何一个root对象到某个对象不可达时，则认为该对象可以被回收</li><li>root对象：<ol><li>栈（栈帧中的本地变量表）中引用的对象</li><li>方法区的静态变量</li><li>方法区中的常量引用的变量</li><li>本地方法栈中的JNI（Native方法）引用的对象</li></ol></li></ol></li></ol></li><li>垃圾回收算法<ol><li>标记-清除：<ol><li>标记阶段：标记那些从根节点开始可到达的对象，未标记的则是待回收对象</li><li>清楚阶段：清除未标记的对象</li><li>优缺点：<ol><li>标记-清除效率不高，都需要从头遍历到尾，会产生大量的不连续内存碎片</li></ol></li></ol></li><li>复制：新生代gc<ol><li>将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，然后清除正在使用的内存块中的所有对象。</li><li>优点：<ol><li>不用考虑内存碎片，只需要移动堆顶指针，按顺序分配内存即可，简单效率高</li></ol></li><li>缺点：<ol><li>空间浪费</li></ol></li><li>补充：现在的商业虚拟机都采用这种收集算法来回收新生代，新生代中的对象98%都是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块比较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。</li><li>当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖于老年代进行分配担保，所以大对象直接进入老年代。</li></ol></li><li>标记-整理：老年代的gc<ol><li>标记阶段：标记从根节点开始的可达对象</li><li>整理阶段：将所有可达对象压缩到内存的一端，之后清理边界外的所有空间</li><li>优点：<ol><li>不产生内存碎片</li></ol></li><li>缺点：<ol><li>在标记的基础上，还需要进行对象的移动，成本相对较高，效率也不高</li></ol></li></ol></li><li>分代收集算法（当前采用）<br> 1. </li></ol></li><li>垃圾回收器<ol><li>Serial收集器：Client模式下的新生代收集器</li><li>Serial old收集器：client模式下的老年代收集器</li><li>ParallNew收集器：server模式下的首选新生代收集器</li><li>G1收集器：更加关注停顿时间</li><li>CMS收集器：并发标记清除，获取最短回收停顿时间为目标，老年代收集器</li></ol></li><li>堆内存划分<ol><li>新生代</li><li>老年代</li><li>永久代</li></ol></li><li>MinorGc ，FullGc</li><li>类加载机制<ol><li>过程：</li><li>类加载器</li><li>双亲委派模型</li></ol></li></ol></li><li>内存泄漏/缓存</li><li>数据结构与排序/查找：<ol><li><ol><li>链表</li><li>栈</li><li>堆</li><li>数组</li><li>树：<ol><li>二叉树（前序，中序，后序），</li><li>平衡二叉树：</li><li>红黑树</li></ol></li><li>图：<ol><li>深度优先遍历：（有些类似二叉树的前序遍历）</li><li>广度优先遍历：（有些类似二叉树的按层次遍历）</li></ol></li><li>实现搜索引擎的搜索建议的后台技术所采用的数据结构：<ol><li>字典树，一种哈希树的变种，快速检索的多叉树。典型用于统计和排序大量的字符串等文本词频</li><li>减少无谓的字符串比较，</li><li>空间换取时间</li></ol></li></ol></li><li>排序：<ol><li>气泡排序</li><li>插入排序</li><li>二叉树排序</li><li>选择排序</li><li>堆排序</li><li>快速排序</li><li>交换排序</li><li>补充：<ol><li>记录规模较小时，n《50，可采用直接插入或直接选择排序；相反n》50，应该采用时间复杂度为O（nlogn）的排序：快速排序，堆排序</li></ol></li></ol></li></ol></li><li>反射与泛型：<ol><li>泛型：泛型的本质就是参数化类型；这种参数类型可用在接口，类，方法的创建中，分别称为泛型接口，泛型类，泛型方法</li></ol></li><li>枚举：Java1.5开始支持，java.lang.Enum为抽象类<ol><li>对Set和Map也提供支持：EnumSet EnumMap</li><li>枚举类中：常量，属性，构造方法，普通方法，抽象方法等</li><li>通过编译，生成抽象类并继承Enum，常量—&gt;final，静态$VALUES[]保存所定义的所有枚举常量；每一个定义的常量都会生成一个final内部类，里面的属性和大部分方法都是final的，通过静态代码块进行初始化，保证了枚举不可变性，不能clone，Serilizable等。</li><li>由3的产生中间类代码，可以知道：Enum相对于静态字符串常量占用的内存是比较大的</li></ol></li><li>动态代理：<ol><li></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;Java主要方面&lt;ol&gt;
&lt;li&gt;面向对象的特性&lt;/li&gt;
&lt;li&gt;集合（特点，数据结构（数组，栈，队列，双向队列，红黑树，二叉树等））&lt;/li&gt;
&lt;li&gt;JVM虚拟机（加载机制/内存以及垃圾回收）&lt;/li&gt;
&lt;li&gt;线程与进程，异步&lt;/li&gt;
&lt;li&gt;注解/反
      
    
    </summary>
    
    
      <category term="java" scheme="http://wenchaos.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>git的常用场景</title>
    <link href="http://wenchaos.com/%E5%B7%A5%E5%85%B7%E7%AF%87/git%E7%9A%84%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://wenchaos.com/工具篇/git的常用场景/</id>
    <published>2018-03-24T16:00:00.000Z</published>
    <updated>2018-04-21T07:38:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git的常用命令"><a href="#git的常用命令" class="headerlink" title="git的常用命令"></a>git的常用命令</h1><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li><p>本地仓库与git remote仓库的关联</p><ul><li>首先要在github账户上，创建与本地仓库同名的仓库repository;</li><li>进入本地仓库的根目录，开始下面一系列的操作<ol><li>可以选择创建readme.md文件；　echo “# -“ &gt;&gt; README.md</li><li>初始化该仓库；　git init</li><li>将创建的文件README.md文件放置暂存区；　git add README.md</li><li>将暂存区的修改提交; git commit -m “你的提交信息”</li><li>将本地仓库推送到github上；git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:账户名/仓库名.git,git push -u origin master</li></ol></li><li>到此已经基本完成。但是还是需要将你的电脑配置一下<ol><li>git config –global user.name “your account name”</li><li>git config –global user.email “your account email”</li><li>到此已经在当前用户配置了你的信息。下面需要生成你的ssh-key并添加到github上</li><li>生成秘钥；ssh-keygen -t rsa -C “your account email” (连续回车三次)</li><li>最后将公钥添加到git账户里，就OK啦。</li></ol></li><li><p>有时候工作环境和个人环境都需要一个秘钥，这时候可以在生成秘钥的时候，指定名字并且需要添加config文件进行指定</p><ol><li>生成指定名称的秘钥；ssh-keygen -t rsa -C “your account email” -f ~/.ssh/指定文件名</li><li><p>添加特别的配置，在ssh目录下新建config文件，内容如下</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host github-aysee</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile <span class="symbol">C:</span>/Users/username/.ssh/aysee</span><br><span class="line">你应该可以看懂的吧－－</span><br></pre></td></tr></table></figure><ol><li>在指定项目下，指定作者<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;Author name&quot;</span><br><span class="line">git config user.email &quot;Author email&quot;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ul></li><li><p>一次git提交生命过程中遇到的兄弟们（这里并不准备详细的介绍这些哥们）</p><ul><li>新建文件/目录，修改，提交</li><li><p>一般仓库中的文件可能存在于这三种状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Untracked files 文件未被跟踪　【处于工作区】</span><br><span class="line">2. Changes to be committed 文件已经被暂存，这是下次提交的内容　【处于暂存区】</span><br><span class="line">3. Changes but not updated 文件被修改，但没有添加到暂存区　【工作区】</span><br></pre></td></tr></table></figure></li><li><p>在开始新的路上，要把有变化的文件添加到索引库中，这个时候首先要遇见：git add命令</p><ol><li>git add -A [path]: 表示把path内的所有的tracked文件那些被修改／被删除／以及untrack的文件，添加到索引库中</li><li>git add -u [path]: 把path中所有的tracked文件，那些被修改／被删除的文件，添加到索引库中</li><li>git add -i [path]: 可以查看到path中所有被修改过／被删除但是还没有提交的文件</li><li>add兄弟家族还有好多，具体可以看看–help管家</li></ol></li><li><p>经历了add家族的接待，那些被添加到索引库的文件即将遇到另外一个兄弟：git commit命令，</p><ol><li>git commit -m “提交的描述信息”　：提交暂存区的文件</li><li>git commit -a -m “提交的描述信息”　：　提交暂存区以及工作区中已被tracked文件</li><li>git commit –amend “再次补充添加上次提交的描述信息”：补充提交信息</li></ol></li><li>经由commit的指引，我们来到了暂存区，这里都是即将要被push到老家的兄弟们：git push命令<ol><li>该命令用于将本地分支更新到暂存区的文件，推送到远程主机：</li><li>git push \&lt;远程主机&gt;　\&lt;本地分支&gt;:\&lt;远程分支名&gt; ; 一般常用 git push，其他更具体的用法请Ｇｏｏｇｌｅ</li><li>常见的一些情况：<ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.git push origin master :表示　将本地分支master推送到origin主机的master分支，如果不存在，则新建</span><br><span class="line">2.git push origin :master 表示　删除指定的远程分支master　</span><br><span class="line">    等同于推送一个空本地分支到远程分支</span><br><span class="line">    git push origin --delete master</span><br><span class="line">3.git push 推送当前分支到远程</span><br><span class="line">4.git push --all　推送所有本地分支到远程</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ul></li></ol><ol><li><p>天下大事，合久必分，分久必合。</p><ul><li><p>接下来git branch主要用法</p><ol><li>git branch 查看本地分支列表，当前分支“*”标示</li><li>git branch \<branchname>　创建分支，基于当前HEAD指向的提交</branchname></li><li>git branch \<branchname> \<start-point>　创建分支，基于指定的提交节点</start-point></branchname></li><li>git branch -d \<branchname> 　删除分支，弱删除（删除时检查索要删除的分支是否已经合并到其他分支中，否则拒绝）</branchname></li><li>git branch -D \<branchname>　强制删除</branchname></li><li>git branch -m \<oldbranch>　\<newbranch> 重命名分支，如果版本库中已经存在newbranch的分支，拒绝</newbranch></oldbranch></li><li>git branch -M \<oldbranch>　\<newbranch>　重命名分支，即使版本库中已经存在newbranch的分支，强制执行</newbranch></oldbranch></li></ol></li><li><p>那么git merge主要用法：把一个分支或某个commit的修改合并到现在的分支上</p><ol><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">usage: git merge [options] [&lt;commit&gt;...]</span><br><span class="line">   or: git merge [options] &lt;msg&gt; HEAD &lt;commit&gt;</span><br><span class="line">   or: git merge --abort</span><br></pre></td></tr></table></figure></li><li><p>先切换到目的分支：git checkout destination-branch</p></li><li>再将目标分支合并到目的分支：　git merge aim-branch</li><li>如果有冲突，先解决，再经过一次提交过程，完成合并</li></ol></li></ul></li></ol><ol><li>关于git的一些必要概念<ul><li>工作区：当前工程目录范围下</li><li>暂存区：即stage，一般存放在工程根目录下的.git/index文件夹，</li><li>版本库：工作区有一个隐藏目录.git　这个就是当前工程的版本库,是一个简单的数据库，其中包含所有用来维护与管理项目修订版本与历史信息。</li></ul></li></ol><p>##Git中rebase与merge的区别<br>    1. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git的常用命令&quot;&gt;&lt;a href=&quot;#git的常用命令&quot; class=&quot;headerlink&quot; title=&quot;git的常用命令&quot;&gt;&lt;/a&gt;git的常用命令&lt;/h1&gt;&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="工具类" scheme="http://wenchaos.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
      <category term="git" scheme="http://wenchaos.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>kotlin基本概念学习</title>
    <link href="http://wenchaos.com/android%E5%BC%80%E5%8F%91/kotlin%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://wenchaos.com/android开发/kotlin基本概念/</id>
    <published>2018-03-14T16:00:00.000Z</published>
    <updated>2019-07-28T07:55:17.652Z</updated>
    
    <content type="html"><![CDATA[<ol><li>协程<ol><li>对于耗时操作（网络io，文件io，cpu或gpu密集的操作），并且要求调用者等待，直到任务完成。协程提供了一种新的方式，可以避免线程阻塞，改为更加廉价可控的操作：协程</li><li>其他：<ol><li>JS的async/await </li><li>Go的channels，select</li><li>C#和python的generators和yield</li></ol></li><li>阻塞（Blocking）与挂起（Suspend）</li><li>简单的讲：协程就是一段计算过程；可以被挂起，但是不会阻塞线程（进程，线程的切换以及阻塞代价是昂贵的）；协程不会在某个随机的代码中挂起，只能在挂起点的地方挂起，即suspend挂起函数</li><li>挂起函数<ol><li>规则和普通函数一样；但是调用者只能是挂起函数，或者是协程，或者是协程或挂起函数中内联的函数字面值</li><li>挂起函数还可以是虚函数，即在接口中定义</li></ol></li><li>协程的内部工作机制 <ol><li>协程完全通过编译技术实现，（不需要VM或OS的特殊支持），挂起则是通过代码转换来实现。基本上，每个挂起函数，在编译期间都被转换为一个状态机，状态机中的各个状态对应于挂起调用。在挂起之前，状态机的下一个状态，以及相关的局部变量等信息，都会被保存到编译器生成的类的成员域变量中。协程恢复执行时，局部变量会被恢复出来，状态机会在挂起之后的状态继续执行。</li><li>协程挂起之后可以作为对象来保存和传递。，对象内部保存了协程的挂起后的状态，以及相关的局部变量等信息。这种对象的类型是Continuation，我们这里描述的整个代码转换过程，其实就是典型的“延续性传递编程风格”。因此挂起函数的底层实现技术会接受一个额外的Continuation的类型参数</li></ol></li><li>async/await/yield详细工作原理</li></ol></li><li>类型别名 typealias</li><li>与对象实例绑定的可调用的引用 <ol><li>操作符:: 用来得到一个成员的引用，指向一个具体的对象实例的方法或者属性</li></ol></li><li>封闭类（sealed class）与数据类（data class）<ol><li>Kotlin1.1中删除了1.0中对封闭类与数据类的一些限制。过去封闭类的子类只能声明在内部，现在可以声明在同一个module内任何一个地方；数据类可以继承其他类</li></ol></li><li>在lambda中使用解构声明</li><li>使用 _ 替代未使用的参数<ol><li>对于接受多个参数的lambda表达式，可以使用 _ 来代替你未使用到的参数</li><li>对于解构声明同样有效</li><li>在数字字面值中使用 _ 如val oneMillion = 1_000_000</li></ol></li><li>简洁的属性语法</li><li>委托属性：by lazy{ }<ol><li>局部的委托属性：可以用来定义一个延迟计算的局部变量（即 函数内部变量进行委托）</li><li>委托属性的拦截：操作符provideDelegate</li></ol></li><li>枚举值访问的通用方式</li><li>操作符<ol><li>onEach（）遍历集合与序列，对所有元素执行相同的操作，并返回iterator实例；与forEach类似</li><li>also（）：类似于apply（）：它得到一个接受者，然后对接受者执行某些操作，最后返回接受者；不同的是also内部是it指代，apply内部是this指代</li><li>takeIf（）类似于filter，但是前者适用于单只，并且满足条件，返回接受者，否则返回null；filter适用于集合序列；</li><li>takeUnless与takeIf相反</li><li>groupBy（）：用来对一个集合按照某个key进行分组，并同时合并所有的组。</li></ol></li><li>数组处理函数</li><li>常数内联 Constant inline：编译器现在可以将const val属性的值内联到这些属性被使用的地方</li><li>智能类型转换</li><li>允许将this::foo简写为::foo<ol><li>绑定到this的成员上的可调用的引用，可以不用明确的指定接受者</li></ol></li><li>基本语法：<ol><li>定义包 package import 目录结构可以与包结构不一致</li><li>函数定义 </li><li>变量定义：val只读（不可变） var读写（可变）<ol><li>属性与作用域</li></ol></li><li>注释</li><li>字符串模板 $</li><li>if else条件表达式，返回最后一行</li><li>when表达式</li><li>范围 in  !in </li><li>集合 val items = listOf(1,2,3)</li><li>数据类 data class Nmae（val name:String）<ol><li>所有属性的getter方法（var类型还有setter方法）</li><li>equals</li><li>hashCode</li><li>toString</li><li>copy</li></ol></li><li>函数参数的指定默认值</li><li>扩展函数</li><li>单例 object SingleObj{  }</li><li>如果不是null  ?.</li><li>如果不是null … else   ?.exp1 ?:   exp2</li><li>对同一个对象实例上调用多个方法  with（receiver）</li><li>代码规范：遵循java</li><li>扩展函数，中缀函数</li><li>范围函数：apply/with/run/also/let<ol><li>内部it：also，let</li><li>内部this</li><li>返回结果：上下文对象：apply，also</li><li>返回结果：某个值：with，let，run</li><li>来自链式调用 是否为null?.let/run/apply；否则with/also（receiver）{}</li></ol></li><li>基本类型<ol><li>数值类，Double Float Long Int Short Byte </li><li>支持进制 2 0b，10，16 0x</li></ol></li><li>相等性<ol><li>== 内容</li><li>=== 对象引用</li></ol></li><li>数组 Array <ol><li>创建方式 <ol><li>arrayOf</li><li>Array（size，lambda）</li></ol></li><li>ByteArray，ShortArray，IntArray 避免数值对象装箱带来的性能损耗 与Array不存在关系</li></ol></li><li>if when 表达式</li><li>do..while，while，for <ol><li>适用于iterator</li><li>return ： 默认行为是从最内层函数返回</li><li>break：结束最内层的循环</li><li>continue ：在最内层循环中，结束当前，跳转到下一次循环</li><li>@返回标签</li></ol></li><li>类与对象<ol><li>构造器 <ol><li>主/次  主构造器没有任何修饰时可省略关键字constructor</li><li>init{}初始化代码段</li><li>构造器中可以直接使用val var来声明对象的属性</li><li>如果类中有主构造器，则每个次级构造器必须委托给主构造器，要么直接委托，要么通过其他次级构造器间接委托 关键字this</li><li>init代码块实际上会 成为主构造器的一部分；会作为次级构造器的第一条语句执行</li></ol></li><li>包含内容<ol><li>构造器+init代码块</li><li>函数</li><li>属性</li><li>嵌套类，内部类</li><li>对象声明</li></ol></li><li>默认情况下kotlin中所有的类都是final的；关键字open显示指定，可以被继承</li><li>子类中有主构造器，则在主构造器中使用其参数来初始化基类</li><li>如果子类没有主构造器，则所有次级构造器都必须使用super关键字来初始化基类，或者间接委托</li><li>方法覆盖 open override final</li><li>属性覆盖：类似方法覆盖</li><li>初始化顺序：<ol><li>子类实例化构造过程中，首先需要初始化基类</li><li>。。</li></ol></li><li>覆盖的规则</li><li>抽象类与接口  <ol><li>默认open，可以有方法实现</li><li>抽象类可以存储状态数据，接口则不行，</li></ol></li><li>伴随对象：类似java静态方法</li></ol></li><li>可见度修饰符  <ol><li>public 默认</li><li>internal：module模块内</li><li>protected：同private，但是子类中可见</li><li>private：当前代码文件内，子类中不可见</li></ol></li><li>扩展<ol><li>扩展函数：    （静态）</li><li>扩展变量</li><li>意义：解决java中各种Utils不美观而且逐渐混乱的写法</li></ol></li><li>数据类</li><li>封闭类</li><li>泛型<ol><li>上界 ？extends E ：接受的参数类型是一个E类型，包括 E子类</li><li>生产者对应extends，消费者对应super</li><li>kotlin中，使用’声明处的类型变异’，确保只会生产T类型，关键字out（协变注解）</li><li>与out相反的是  ‘in’ 反向类型变异，只能用于消费者，如 Compareable</li><li>星号<em>投射， Function&lt;</em> ,String&gt;</li><li>泛型函数</li><li>泛型约束  即上界约束</li><li>类型擦除：kotlin只在编译器进行类型安全检查，泛型类型的实例不保存关于其类型参数的任何信息，比如Foo<int> 其类型信息会被擦除，只剩下Foo&lt;*&gt;</int></li></ol></li><li>嵌套类Nested class：类似于java的静态内部类<ol><li>class A{   class B{ }   }</li></ol></li><li>内部类Inner class  ：类似于java的内部类，持有外部类对象的一个引用<ol><li>class A{   inner class B{ }   }</li></ol></li><li>匿名内部类：类似于接口回调 可以使用lambda表示</li><li>枚举类 enum class Color{ RED，GREEN}<ol><li>每个枚举类常数都是一个对象，都是该枚举类的一个实例</li><li>也可以定义自己的匿名内部类</li></ol></li><li>对象表达式与对象声明<ol><li>有时我们需要在某个类基础上略作修改，但是又不希望重新声明一个新类，java中使用匿名内部类，kotlin中可以使用对象表达式或者对象声明</li><li>对象表达式：  <ol><li>setListenner(object : OnClickListener { } )</li><li>val person = object{ var name:String=“john”}</li><li>可以访问创建这个对象的代码范围内的变量</li></ol></li><li>注意：只有在局部并且私有的声明范围内，匿名对象才可以被用作类型。如果匿名对象作为公开函数的返回类型，或者公开属性的类型，那么这个函数或者属性的真实类型，会被     声明为这个匿名 对象的超类</li><li>对象声明： 不是一个表达式，因此不能出现在等式右边<ol><li>object Room{ }  </li><li>单例模式</li><li>对象声明中的初始化是线程安全的</li><li>伴随对象：<ol><li>在一个类的内部进行对象声明 关键字companion；</li><li>虽然伴随对象有些像java中类的静态成员，但是在运行期间，这些成员仍然是真是对象的实例的成员，它们与静态成员是不同的；举例来说就是，它们也可以实现接口</li><li>如果使用@JvmStatic注解，则可以让伴随对象在JVM上被编译为真正的静态方法和静态域</li></ol></li></ol></li><li>对象表达式与对象声明的不同：<ol><li>对象表达式，在使用处立即执行初始化</li><li>对象声明，是延迟初始化的，只会在首次访问到的时候进行初始化</li><li>伴随对象会在对应的类被装载解析时初始化，语义上等同于java中的静态初始化块</li></ol></li></ol></li><li>委托<ol><li>类的委托</li><li>属性的委托：有许多具有共性的属性，虽然可以在每个使用这些属性的类中手动实现它们，但是能够只实现一次，然后将它放在库中供所有需要的类使用，那将会好很多。比如<ol><li>延迟加载属性  by lazy：只有在初次访问时进行初始化，线程安全（如果不需要线程安全，则可以LayThreadSafetyMode.PUBLICATION，如果你确信初始化计算一定只发生在一个线程中，可以LayThreadSafetyMode.NONE来避免多余的线程同步带来的性能损耗）</li><li>可观察属性：observable ： 属性在发生变化时，可以向监听器发生通知<br> 1. </li><li>将多个属性保存在一个map中国馆过过过过，而不是将每个属性保存在一个独立的域</li></ol></li><li>为了解决这些以及其他问题，kotlin提供委托属性：<ol><li>语法：val/var propertyName : Type by  expr0 ；by后边是表达式，即委托属性的get、set方法将要被委托给这个expr0的对象的getValue 和setValue。</li></ol></li></ol></li><li>函数<ol><li>函数声明，函数参数，默认值，返回值，单表达式函数，不定数量参数varargs</li><li>中缀标记法 （关键字 infix 标记函数）<ol><li>优先级：infix 低于 算术运算符，类型转换，rangeTo；高于 布尔值运算符， &amp;&amp;， ||， is， in，</li></ol></li><li>函数范围：<ol><li>顶级函数，</li><li>类函数，</li><li>局部函数（函数中的函数），</li><li>扩展函数，</li><li>内联函数：<ol><li>关键字inline 标识函数</li><li>inline 既会影响到函数本身，也会影响到传递给它的lambda表达式：这两者都会被内联到调用处（因此会导致编译后代码体积增加，需要合理使用内联）</li><li>noinline标识不进行内联使用</li><li>内联属性：会将getter setter的内联到调用处</li><li>对Public API内联函数的限制：<ol><li>当一个内联函数为public 或 protected，则这个函数被认为是一个module的public api；其他module可以调用，并且被内联到调用处；此时可能会造成二进制代码不兼容的风险</li></ol></li></ol></li><li>高阶函数与lambda表达式<ol><li>定义：高阶函数是一种特殊的函数，它可以用函数当做入参，或者返回一个函数</li><li>lambda表现方式：<ol><li>Lambda表达式用大括号括起来 { }</li><li>参数（如果存在）定义在-&gt;之前，参数类型可以省略</li><li>（如果-&gt;存在）函数体定义在-&gt;之后</li><li>调用一个函数时，如果最后一个参数是函数类型，则可以用lambda表达式作为这函数参数的值</li><li>调用函数时，如果仅有一个唯一的函数类型的参数，则整个（）可以省略</li><li>使用下划线代替未使用到的参数</li></ol></li><li>匿名函数</li><li>闭包</li><li>带有接受者的函数字面值</li><li>缺点：高阶函数在运行时会带来一些不利：每个函数都是一个对象，而且它还要捕获一个闭包，也就是在函数体内部访问的那些外层变量。导致内存占用（函数对象和类都是会占用内存的）以及虚方法调用都会带来运行时的消耗；而很多情况下，编译器将lambda表达式内联在使用处，可以消除这些运行时消耗</li></ol></li><li>尾递归函数 （关键字 tailrec 标识函数 ）替代某些循环算法，同时不会存在栈溢出异常；编译器会对代码进行优化，消除函数的递归调用，产生一段基于循环实现的，快速且高效的代码；不能将尾递归用在try、catch结构中</li></ol></li></ol></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;协程&lt;ol&gt;
&lt;li&gt;对于耗时操作（网络io，文件io，cpu或gpu密集的操作），并且要求调用者等待，直到任务完成。协程提供了一种新的方式，可以避免线程阻塞，改为更加廉价可控的操作：协程&lt;/li&gt;
&lt;li&gt;其他：&lt;ol&gt;
&lt;li&gt;JS的async/await 
      
    
    </summary>
    
      <category term="笔记" scheme="http://wenchaos.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="kotlin" scheme="http://wenchaos.com/tags/kotlin/"/>
    
  </entry>
  
</feed>
